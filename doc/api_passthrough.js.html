<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api/passthrough.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/passthrough.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * This file contains functions meant to consolidate all EarSketch API functions
 * into a single source. Both the Python and Javascript libraries are simply
 * wrappers for these functions.
 *
 * If your API function needs to be asynchronous, make sure it returns a
 * promise, and use suspendPassthrough() in the Javascript and Python wrappers.
 *
 * TODO: consolidate range checking and the corresponding
 * error throwing in the addClip() and addEffect() methods. Right now it is
 * duplicated in every API function.
 *
 * @module Passthrough
 * @author Creston Bunch
 */

ES_PASSTHROUGH = {
    /**
     * Set the initial state of the result object.
     */
    init: function(result, quality) {
        esconsole(
            'Calling pt_init from passthrough',"PT"
        );

        return {
            tempo: 120,
            length: 0,
            quality: quality,
            tracks: []
        }
    },

    /**
     * Set the tempo on the result object.
     */
    setTempo: function(result, tempo) {
        esconsole(
            'Calling pt_setTempo from passthrough with parameter ' +
            tempo, ['DEBUG','PT']
        );

        var args = copyArgs(arguments).slice(1); // remove first argument

        ptCheckArgs('setTempo', args, 1, 1);
        ptCheckType('tempo', 'number', tempo);
        ptCheckRange('setTempo', tempo, 45, 220);

        result.tempo = tempo;

        return result;
    },

    /**
     * Run steps to clean up the script.
     */
    finish: function(result) {
        esconsole(
            'Calling pt_finish from passthrough',"PT"
        );

        // do nothing
        return result;
    },

    /**
     * Add a clip to the given result object.
     */
    fitMedia: function(
        result, filekey, trackNumber, startLocation, endLocation
    ) {

        esconsole(
            'Calling pt_fitMedia from passthrough with parameters '
            + filekey + ' , '
            + trackNumber + ' , '
            + startLocation + ' , '
            + endLocation,'PT');

        var args = copyArgs(arguments).slice(1); // remove first argument

        ptCheckArgs('fitMedia', args, 4, 4);
        ptCheckType('filekey', 'string', filekey);
        ptCheckFilekeyType(filekey);
        ptCheckType('trackNumber', 'number', trackNumber);
        ptCheckType('startLocation', 'number', startLocation);
        ptCheckType('endLocation', 'number', endLocation);

        var clip = {
            filekey: filekey,
            track: trackNumber,
            measure: startLocation,
            start: 1,
            end: endLocation - startLocation + 1,
            scale: false,
            loop: true
        };

        addClip(result, clip);

        return result;
    },

    /**
     * Insert a media clip.
     */
    insertMedia: function(
        result, fileName, trackNumber, trackLocation, scaleAudio
    ) {

        esconsole(
            'Calling pt_insertMedia from passthrough with parameters '
            + fileName + ' , '
            + trackNumber + ' , '
            + trackLocation + ' , '
            + scaleAudio,'PT');

        args = copyArgs(arguments).slice(1); // remove first argument

        ptCheckArgs('insertMedia', args, 2, 4);
        ptCheckType('fileName', 'string', fileName);
        ptCheckFilekeyType(fileName);
        ptCheckType('trackNumber', 'number', trackNumber);

        // Now check if the optional parameters have valid datatypes. If not specified, initialize to defaults.
        if (trackLocation !== undefined) {
            if (typeof(trackLocation) !== 'number') {
                throw new TypeError('trackLocation must be a number');
            }
        } else {
            trackLocation = 1.0;
        }

        if (scaleAudio !== undefined) {
            if (typeof(scaleAudio) !== 'number') {
                throw new TypeError('scaleAudio must be a number');
            }
        } else {
            scaleAudio = 1;
        }

        var clip = {
            filekey: fileName,
            track: trackNumber,
            measure: trackLocation,
            start: 1,
            end: 0,
            scale: scaleAudio,
            loop: true
        };

        addClip(result, clip);

        return result;
    },

    /**
     * Insert a media clip section.
     */
    insertMediaSection: function(
        result,
        fileName,
        trackNumber,
        trackLocation,
        mediaStartLocation,
        mediaEndLocation,
        scaleAudio
    ) {

        esconsole(
            'Calling pt_insertMediaSection from passthrough with parameters '
            + fileName + ' , '
            + trackNumber + ' , '
            + trackLocation + ' , '
            + mediaStartLocation + ' , '
            + mediaEndLocation + ' , '
            + scaleAudio,"PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('insertMediaSection', args, 3, 6);
        ptCheckType('fileName', 'string', fileName);
        ptCheckFilekeyType(fileName);
        ptCheckType('trackNumber', 'number', trackNumber);
        ptCheckType('trackLocation', 'number', trackLocation);

        if (mediaStartLocation !== undefined) {
            if (typeof(mediaStartLocation) !== 'number') {
                throw new TypeError('mediaStartLocation must be a number');
            }
        } else {
            mediaStartLocation = 0;
        }

        if (mediaEndLocation !== undefined) {
            if (typeof(mediaEndLocation) !== 'number') {
                throw new TypeError('mediaEndLocation must be a number');
            }
        } else {
            mediaEndLocation = 0;
        }

        if (scaleAudio !== undefined) {
            if (typeof(scaleAudio) !== 'number') {
                throw new TypeError('scaleAudio must be a number');
            }
        } else {
            scaleAudio = 1;
        }

        var clip = {
            filekey: fileName,
            track: trackNumber,
            measure: trackLocation,
            start: mediaStartLocation,
            end: mediaEndLocation,
            scale: scaleAudio,
            loop: true
        };

        addClip(result, clip);

        return result;
    },

    /**
     * Make a beat of audio clips.
     */
    makeBeat: function(result, media, track, measure, beatString) {
        esconsole(
            'Calling pt_makeBeat from passthrough with parameters '
            + media + ' , '
            + track + ' , '
            + measure + ' , '
            + beatString,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('makeBeat', args, 4, 4);

        if (media.constructor !== Array &amp;&amp; typeof(media) !== 'string') {
            throw new TypeError('media must be a list or a string');
        }

        ptCheckType('track', 'number', track);
        ptCheckType('measure', 'number', measure);
        ptCheckType('beatString', 'string', beatString);

        // ensure input media is a list
        var mediaList = [];
        if (typeof(media) == "object") {
            for (var i = 0; i &lt; media.length; i++) {
                mediaList.push(media[i]);
            }
        } else {
            mediaList.push(media);
        }

        var SUSTAIN = "+";
        var REST = "-";
        var SIXTEENTH = 0.0625;

        // parse the beat string
        for (var i = 0; i &lt; beatString.length; i++) {
            var current = parseInt(beatString[i]);
            // add a rest at the "end" so that any number in the last index gets
            // included
            var next = (i &lt; beatString.length - 1) ? beatString[i + 1] : REST;

            // current beat is a valid number
            if (!isNaN(current)) {
                var filekey = mediaList[current];
                var location = measure + (i * SIXTEENTH);
                var start = 1; //measure + (i * SIXTEENTH);
                var end = start + SIXTEENTH;
                var silence = 0;

                if (next == REST) {
                    // next char is a rest, so we calculate the length and
                    // add silence to the end if necessary
                    var j = i+1;
                    while (isNaN(parseInt(beatString[j])) &amp;&amp;
                           j++ &lt; beatString.length) {
                    }
                    if (j >= beatString.length) {
                        silence += (j-i-2)*SIXTEENTH;
                    }

                } else if (next == SUSTAIN) {
                    // next char is a sustain, so add to the end length
                    // the number of sustain characters in a row
                    var j = i+1;
                    while (beatString[j] == SUSTAIN &amp;&amp; j++ &lt; beatString.length){
                        end += SIXTEENTH;
                    }
                    // skip ahead (for speed)
                    i = j-1;

                    // next char is a rest, so we calculate the length and
                    // add silence to the end if necessary
                    var j = i+1;
                    while (beatString[j] == REST &amp;&amp;
                           j++ &lt; beatString.length) {
                    }
                    if (j >= beatString.length) {
                        silence += (j-i-1)*SIXTEENTH;
                    }
                }

                var clip = {
                    filekey: filekey,
                    track: track,
                    measure: location,
                    start: start,
                    end: end,
                    scale: false,
                    loop: false
                };

                addClip(result, clip, silence);
            }
        }

        return result;
    },

    /**
     * Make a beat from media clip slices.
     */
    makeBeatSlice: function(
        result, media, track, measure, beatString, beatNumber
    ) {
        esconsole(
            'Calling pt_makeBeatSlice from passthrough with parameters '
            + media + ' , '
            + track + ' , '
            + measure + ' , '
            + beatString + ' , '
            + beatNumber,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('makeBeatSlice', args, 5, 5);
        ptCheckType('media', 'string', media);
        ptCheckFilekeyType(media);
        ptCheckType('track', 'number', track);
        ptCheckType('measure', 'number', measure);
        ptCheckType('beatString', 'string', beatString);

        if (beatNumber.constructor !== Array
            &amp;&amp; typeof(beatNumber) !== 'number') {
            throw new TypeError('beatNumber must be a list or a number');
        }

        if (beatNumber.constructor === Array) {
            beatNumber.forEach(function (v) {
                if (typeof(v) !== 'number') {
                    throw new TypeError(
                        'beatNumber values must be numbers.'
                    );
                } else {
                    if (v &lt; 1) {
                        throw new RangeError(
                            'beatNumber values cannot be below 1.'
                        );
                    }
                }
            });
        }

        // ensure input beats is a list
        var beatList = [];
        if (typeof(beatNumber) == "object") {
            for (var i = 0; i &lt; beatNumber.length; i++) {
                beatList.push(beatNumber[i]);
            }
        } else {
            beatList.push(media);
        }

        var SUSTAIN = "+";
        var REST = "-";
        var SIXTEENTH = 0.0625;

        // parse the beat string
        for (var i = 0; i &lt; beatString.length; i++) {
            var current = parseInt(beatString[i]);
            // add a rest at the "end" so that any number in the last index gets
            // included
            var next = (i &lt; beatString.length - 1) ? beatString[i + 1] : REST;

            // current beat is a valid number
            if (!isNaN(current)) {
                var start = measure + (i * SIXTEENTH);
                var sliceStart = beatList[current];
                var sliceEnd = beatList[current] + SIXTEENTH;

                if (next == REST) {
                    // next char is a rest, so do nothing
                } else if (next == SUSTAIN) {
                    // next char is a sustain, so add to the end length
                    // the number of sustain characters in a row
                    var j = i + 1;
                    while (beatString[j] == SUSTAIN &amp;&amp; j++ &lt; beatString.length){
                        sliceEnd += SIXTEENTH;
                    }
                    // skip ahead
                    i = j-1;
                }

                result = ES_PASSTHROUGH.insertMediaSection(
                    result, media, track, start, sliceStart, sliceEnd
                );
            }
        }

        return result
    },

    /**
     * Analyze a clip.
     *
     * Returns the analyzed value. Does not alter the result (it just takes it
     * as a parameter for consistency).
     */
    analyze: function(result, audioFile, featureForAnalysis) {

        esconsole(
            'Calling pt_analyze from passthrough with parameters '
            + audioFile + ' , '
            + featureForAnalysis,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('analyze', args, 2, 2);
        ptCheckType('audioFile', 'string', audioFile);
        ptCheckFilekeyType(audioFile);
        ptCheckType('featureForAnalysis', 'string', featureForAnalysis);

        // load an angular service outside angular
        var audioLibrary = ServiceWrapper().audioLibrary;

        var tempo = result.tempo;
        var q = result.quality;

        return audioLibrary.getAudioClip(audioFile, result.tempo, q).then(
            function(buffer) {
                return ESAnalyze(buffer, featureForAnalysis, tempo);
            }
        ).catch(function(err) {
            throw err;
        });
    },

    /**
     * Analyze a clip for time.
     *
     * Returns the analyzed value. Does not alter the result.
     */
    analyzeForTime: function(
        result, audioFile, featureForAnalysis, startTime, endTime
    ) {
        esconsole(
            'Calling pt_analyzeForTime from passthrough with parameters '
            + audioFile + ' , '
            + featureForAnalysis + ' , '
            + startTime + ' , '
            + endTime,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('analyzeForTime', args, 4, 4);
        ptCheckType('featureForAnalysis', 'string', featureForAnalysis);
        ptCheckType('audioFile', 'string', audioFile);
        ptCheckFilekeyType(audioFile);
        ptCheckType('startTime', 'number', startTime);
        ptCheckType('endTime', 'number', endTime);

        if (startTime > endTime) {
            throw new RangeError(
                'Cannot have start time greater than end time in Analysis call'
            );
        }

        // load an angular service outside angular
        var audioLibrary = ServiceWrapper().audioLibrary;

        var tempo = result.tempo;
        var q = result.quality;
        return audioLibrary.getAudioClip(audioFile, result.tempo, q).then(
            function(buffer) {
                var result = ESAnalyzeForTime(
                    buffer, featureForAnalysis, startTime, endTime, tempo
                );
                return result;
            }
        ).catch(function(err) {
            throw err;
        });
    },

    analyzeTrack: function(result, trackNumber, featureForAnalysis) {
        esconsole('Calling pt_analyzeTrack from passthrough with parameters '
                  + trackNumber + ' , '
                  + featureForAnalysis,
                  'PT');

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('analyzeTrack', args, 2, 2);
        ptCheckType('trackNumber', 'number', trackNumber);
        ptCheckType('featureForAnalysis', 'string', featureForAnalysis);

        // load an angular service outside angular
        var compiler = ServiceWrapper().compiler;
        var renderer = ServiceWrapper().renderer;

        var tempo = result.tempo;
        // the analyzeResult will contain a result object that contains only
        // one track that we want to analyze
        var analyzeResult = {
            tempo: result.tempo,
            tracks: [{clips:[],effects:{}}, result.tracks[trackNumber]],
            quality: result.quality,
            length: result.length
        }
        return compiler.postCompile(analyzeResult).then(function(compiled) {
            // TODO: analyzeTrackForTime FAILS to run a second time if the
            // track has effects using renderer.renderBuffer()
            // Until a fix is found, we use mergeClips() and ignore track
            // effects.
            //return renderer.renderBuffer(result);
            var clips = compiled.tracks[1].clips;
            var buffer = renderer.mergeClips(clips, result.tempo);
            return buffer;
        }).catch(function(err) {
            throw err;
        }).then(function(buffer) {
            return ESAnalyze(buffer, featureForAnalysis, tempo);
        }).catch(function(err) {
            throw err;
        });
    },

    analyzeTrackForTime: function(
        result, trackNumber, featureForAnalysis, startTime, endTime
    ) {
        esconsole(
            'Calling pt_analyzeTrackForTime from passthrough with parameters '
            + trackNumber + ' , '
            + featureForAnalysis + ' , '
            + startTime + ' , '
            + endTime,
            'PT'
        );
        args = copyArgs(arguments).slice(1);

        ptCheckArgs('analyzeTrackForTime', args, 4, 4);
        ptCheckType('featureForAnalysis', 'string', featureForAnalysis);
        ptCheckType('trackNumber', 'number', trackNumber);
        ptCheckType('startTime', 'number', startTime);
        ptCheckType('endTime', 'number', endTime);

        if (startTime > endTime) {
            throw new RangeError(
                'Cannot have start time greater than end time in Analysis call.'
            );
        }

        // load an angular service outside angular
        var compiler = ServiceWrapper().compiler;
        var renderer = ServiceWrapper().renderer;

        var tempo = result.tempo;
        // the analyzeResult will contain a result object that contains only
        // one track that we want to analyze
        var analyzeResult = {
            tempo: result.tempo,
            tracks: [{clips:[],effects:{}}, result.tracks[trackNumber]],
            quality: result.quality,
            length: result.length
        }

        return compiler.postCompile(analyzeResult).then(function(compiled) {
            // TODO: analyzeTrackForTime FAILS to run a second time if the
            // track has effects using renderer.renderBuffer()
            // Until a fix is found, we use mergeClips() and ignore track
            // effects.
            var clips = compiled.tracks[1].clips;
            var buffer = renderer.mergeClips(clips, result.tempo);
            return buffer;
        }).catch(function(err) {
            esconsole(err.toString(), ['ERROR','PT']);
            throw err;
        }).then(function(buffer) {
            return ESAnalyzeForTime(
                buffer, featureForAnalysis, startTime, endTime, tempo
            );
        }).catch(function(err) {
            esconsole(err.toString(), ['ERROR','PT']);
            throw err;
        });
    },

    /**
     * Get the duration of a clip.
     */
    dur: function(result, fileKey) {
        esconsole('Calling pt_dur from passthrough with parameters '
                  + fileKey, 'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('dur', args, 1, 1);
        ptCheckType('fileKey', 'string', fileKey);

        // load an angular service outside angular
        var audioLibrary = ServiceWrapper().audioLibrary;

        var q = result.quality;
        return audioLibrary.getAudioClip(fileKey, result.tempo, q).then(
            function(buffer) {
                return ESDur(buffer, result.tempo);
            }
        ).catch(function(err) {
            throw err;
        });
    },

    /**
     * Return a Gaussian distributed random number.
     */
    gauss: function(result, mean, stddev) {
        esconsole(
            'Calling pt_gauss from passthrough with parameters '
            + mean + ' '
            + stddev,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('gauss', args, 0, 2);

        return Math.randomGaussian(mean, stddev);
    },

    /**
     * Import an image as number data.
     */
    importImage: function(result, imageURL, nrows, ncols, color) {
        esconsole(
            'Calling pt_importImage from passthrough with parameters '
            + imageURL + ' , '
            + nrows + ' , '
            + ncols + ' , '
            + color,
            "PT");

        args = copyArgs(arguments).slice(1);

        ptCheckArgs('importImage', args, 3, 4);
        ptCheckType('imageURL', 'string', imageURL);
        ptCheckType('nrows', 'number', nrows);
        ptCheckType('ncols', 'number', ncols);

        if (color !== undefined) {
            ptCheckType('color', 'boolean', color);
        } else {
            color = false;
        }

        // make the HTTP request
        var formData = new FormData();

        formData.append('image_url', imageURL);
        formData.append('width', nrows);
        formData.append('heigth', ncols);
        formData.append('color', color ? true : false);

        var request = new XMLHttpRequest();
        // TODO: synchronous requests are deprecated, come up with a better way
        // to do this
        request.open(
            'POST', URL_DOMAIN+'/services/files/stringifyimage', false
        );

        var response = [];
        request.onload = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    response = JSON.parse(request.responseText);

                    esconsole('Image data received: ' + response,'PT');
                }
            }
        };
        request.onerror =  function(){
            throw new InternalError('We could not load the image.');
        };

        // make the request
        request.send(formData);

        return response;
    },

    importFile: function(result, fileURL) {
        esconsole('Calling pt_importFile from passthrough with parameters '
                  + fileURL,
                  'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('importFile', args, 1, 1);
        ptCheckType('fileURL', 'string', fileURL);

        var result= ['Working'];

        // make the HTTP request
        var formData = new FormData();

        formData.append('file_url', fileURL);

        var request = new XMLHttpRequest();
        // TODO: synchronous requests are deprecated, come up with a better way
        // to do this
        request.open(
            'POST', URL_DOMAIN+'/services/files/stringifyfile', false
        );

        var response = '';
        request.onload = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    response = request.responseText;
                    esconsole('File data received: ' + response,'PT');
                } else {
                    throw new InternalError(
                        'We could not load the file. There was a bad server'
                        + ' response.'
                    );
                }
            }
        };
        request.onerror =  function(){
            throw new InternalError('We could not load the file.');
        };

        // make the request
        request.send(formData);

        return response;
    },

    /**
     * Provides a way to print to the EarSketch console.
     */
    println: function(result, msg) {
        esconsole(
            'Calling pt_println from passthrough with parameter '
            + msg,
            "PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('println', args, 1, 1);

        // load an angular service outside angular
        var userConsole = ServiceWrapper().userConsole;
        userConsole.log(msg);
    },

    /**
     * Prompt for user input.
     */
    prompt: function(result, msg) {
        esconsole('Calling pt_prompt from passthrough with parameter '
                  + msg, 'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('prompt', args, 0, 1);
        if (msg !== undefined) {
            ptCheckType('prompt', 'string', msg);
        } else {
            msg = "";
        }

        return prompt(msg);
    },

    /**
     * Replace a list element.
     */
    replaceListElement: function(
        result, inputList, elementToReplace, withElement
    ) {
        esconsole(
            'Calling pt_replaceListElement from passthrough with parameters '
            + inputList + ' , '
            + elementToReplace + ' , '
            + withElement,
            "PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('replaceListElement', args, 3, 3);
        ptCheckType('inputList', 'array', inputList);
        ptCheckType('elementToReplace', 'string', elementToReplace);
        ptCheckType('withElement', 'string', withElement);

        inputList = inputList.slice(); // create a copy
        for (var i = 0; i &lt; inputList.length; i++) {
            if (inputList[i] == elementToReplace) {
                inputList[i] = withElement;
            }
        }

        return inputList;
    },

    /**
     * Replace a character in a string.
     */
    replaceString: function(
        result, patternString, characterToReplace, withElement
    ) {
        esconsole(
            'Calling pt_replaceString from passthrough with parameters '
            + patternString + ' , '
            + characterToReplace + ' , '
            + withElement,
            "PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('replaceString', args, 3, 3);
        ptCheckType('patternString', 'string', patternString);
        ptCheckType('characterToReplace', 'string', characterToReplace);
        ptCheckType('withElement', 'string', withElement);

        var patternList = patternString.split('');
        var newstring;
        for (var i = 0; i &lt; patternString.length; i++) {
            if (patternList[i] == characterToReplace) {
                patternList[i] = withElement;
            }
        }
        newstring = patternList.join('');
        return newstring;
    },

    /**
     * Reverse a list.
     */
    reverseList: function(result, inputList) {
        esconsole(
            'Calling pt_reverseList from passthrough with parameters '
            + inputList,"PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('reverseList', args, 1, 1);
        ptCheckType('inputList', 'array', inputList);

        inputList = inputList.slice(); // create a copy
        return inputList.reverse();
    },

    /**
     * Reverse a string.
     */
    reverseString: function(result, inputString) {
        esconsole(
            'Calling pt_reverseString from passthrough with parameters '
            + inputString
            ,"PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('reverseString', args, 1, 1);
        ptCheckType('inputString', 'string', inputString);

        return inputString.split('').reverse().join('');
    },

    /**
     * Create a rhythmic effect envelope from a string.
     */
    rhythmEffects: function(
        result,
        track,
        effectType,
        effectParameter,
        effectList,
        measure,
        beatString
    ) {
        esconsole(
            'Calling pt_rhythmEffects from passthrough with parameters '
            + track + ' , '
            + effectType + ' , '
            + effectParameter + ' , '
            + effectList + ' , '
            + measure + ' , '
            + beatString,
            "PT");

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('rhythmEffects', args, 6, 6);
        ptCheckType('track', 'number', track);
        ptCheckType('effectType', 'string', effectType);
        ptCheckType('effectParameter', 'string', effectParameter);
        ptCheckType('effectList', 'array', effectList);
        ptCheckType('measure', 'number', measure);
        ptCheckType('beatString', 'string', beatString);

        var SUSTAIN = "+";
        var RAMP = "-";
        var SIXTEENTH = 0.0625;

        var prevValue = undefined;
        var prevMeasure = measure;

        for (var i = 0; i &lt; beatString.length; i++) {
            var current = beatString[i];
            var next = beatString[i+1];
            var currentValue = prevValue;
            var startMeasure = measure + (i * SIXTEENTH);

            if (!isNaN(parseInt(current))) {
                // parsing a number, set a new previous value

                var prevValue = effectList[parseInt(current)];
            } else if (isNaN(parseInt(current)) &amp;&amp; next !== current) {
                // not currently parsing a number and the next char is not
                // the same as the current char
                var endValue = currentValue;

                if (current == RAMP &amp;&amp; !isNaN(parseInt(next))) {
                    // case: ramp to number
                    endValue = effectList[parseInt(next)];
                } else if (current == SUSTAIN &amp;&amp; !isNaN(parseInt(next))) {
                    // case: sustain to number
                    endValue = currentValue;
                } else if (current == RAMP &amp;&amp; next == SUSTAIN) {
                    // case: ramp to sustain

                    // move to next value
                    while (beatString[++i] == SUSTAIN
                           &amp;&amp; i++ &lt; beatString.length) { }

                    // found a  number
                    if (!isNaN(parseInt(beatString[i-1]))) {
                        endValue = effectList[parseInt(beatString[i-1])];
                    } else {
                        throw RangeError('Invalid beatString.');
                    }

                } else if (current == SUSTAIN &amp;&amp; next == RAMP) {
                    // case: sustain to ramp
                    endValue = currentValue;
                }

                var endMeasure = measure + (1 + i) * SIXTEENTH;

                var effect = {
                    track: track,
                    name: effectType,
                    parameter: effectParameter,
                    startValue: currentValue,
                    endValue: endValue,
                    startMeasure: prevMeasure,
                    endMeasure: endMeasure
                };

                addEffect(result, effect);

                prevMeasure = endMeasure;
                prevValue = endValue;
            }
        }
        return result;
    },

    setEffect: function(
        result, trackNumber, effect, parameter, effectStartValue,
        effectStartLocation, effectEndValue, effectEndLocation
    ) {
        esconsole(
            'Calling pt_setEffect from passthrough with parameters '
            + trackNumber + ' , '
            + effect + ' , '
            + parameter + ' , '
            + effectStartValue + ' , '
            + effectStartLocation + ' , '
            + effectEndValue + ' , '
            + effectEndLocation,
            'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('setEffect', args, 2, 7);
        ptCheckType('trackNumber', 'number', trackNumber);
        ptCheckType('effect', 'string', effect);

        if (parameter !== undefined) {
            ptCheckType('parameter', 'string', parameter);
        } else {
            parameter = effectDefaults[effect].DEFAULT_PARAM;
        }

        if (effectStartValue !== undefined) {
            ptCheckType('effectStartValue', 'number', effectStartValue);
        } else {
            effectStartValue = effectDefaults[effect][parameter].defaultVal;
        }

        if (effectStartLocation !== undefined) {
            ptCheckType('effectStartLocation', 'number', effectStartLocation);
            ptCheckRange('effectStartLocation', effectStartLocation, {min: 1});
        } else {
            effectStartLocation = 1;
        }

        if (effectEndValue !== undefined) {
            ptCheckType('effectEndValue', 'number', effectEndValue);
        } else {
            effectEndValue = effectStartValue;
        }

        if (effectEndLocation !== undefined) {
            ptCheckType('effectEndLocation', 'number', effectEndLocation);
            ptCheckRange('effectEndLocation', effectEndLocation, {min: 1});
        } else {
            effectEndLocation = 0;
        }

        var effect = {
            track: trackNumber,
            name: effect,
            parameter: parameter,
            startValue: effectStartValue,
            endValue: effectEndValue,
            startMeasure: effectStartLocation,
            endMeasure: effectEndLocation
        };

        addEffect(result, effect);

        return result;
    },

    /**
     * Select a random file.
     */
    selectRandomFile: function(result, folder, extension) {

        esconsole('Calling pt_selectRandomFile from passthrough with '
                  + 'parameters ' + folder + ' , ' + extension, 'PT');
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('selectRandomFile', args, 1, 2);
        ptCheckType('folder', 'string', folder);

        if (extension !== undefined) {
            ptCheckType('extension', 'string', extension);
        } else {
            extension = '.wav';
        }

        var request = new XMLHttpRequest();
        request.open('GET', URL_DOMAIN +
                     '/services/audio/getaudiokeys?tag=' + folder, false);
        request.send(null);

        if (request.status === 200) {
            var jsobj = JSON.parse(request.responseText);
            var jsarray = jsobj.audioFiles;
            if (jsarray instanceof Array) {
                var index = Math.floor(Math.random() * jsarray.length);
                return (jsarray[index].file_key);
            } else {
                return (jsarray.file_key);
            }
        } else {
            throw new RuntimeError(
                'Internal server error. '
                + 'Could not respond to the following tag: ' + folder);
        }
    },

    /**
     * Shuffle a list.
     */
    shuffleList: function(result, array) {
        esconsole('Calling pt_shuffleList from passthrough with parameters '
                  + array, 'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('shuffleList', args, 1, 1);
        ptCheckType('inputList', 'array', array);

        // Fisher-Yates
        var a = array;
            n = a.length;

        for(var i = n - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }

        return a;
    },

    /**
     * Shuffle a string.
     */
    shuffleString: function(result, inputString) {
        esconsole('Calling pt_shuffleString from passthrough with parameters '
                  + inputString, 'PT');

        args = copyArgs(arguments).slice(1);
        ptCheckArgs('shuffleString', args, 1, 1);
        ptCheckType('inputString', 'string', inputString);

        // Fisher-Yates
        var a = inputString.split(""),
            n = a.length;

        for(var i = n - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
        return a.join("");
    },

    /* P5 functions TODO: document */

    drawLine: function(result, x1, y1, x2, y2, color) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawLine', args, 5, 5);
        ptCheckType('x1', 'number', x1);
        ptCheckType('y1', 'number', y1);
        ptCheckType('x2', 'number', x2);
        ptCheckType('y2', 'number', y2);
        ptCheckType('color', 'string', color);
        drawLine(x1, y1, x2, y2, color);
        return;
    },

    drawRectangle: function(result, x, y, width, height, color) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawRectangle', args, 5, 5);
        ptCheckType('x', 'number', x);
        ptCheckType('y', 'number', y);
        ptCheckType('width', 'number', width);
        ptCheckType('height', 'number', height);
        ptCheckType('color', 'string', color);

        drawRectangle(x, y, width, height, color);
        return;
    },

    drawPolygon: function(result, x, y, radius, sides, color) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawPolygon', args, 5, 5);
        ptCheckType('x', 'number', x);
        ptCheckType('y', 'number', y);
        ptCheckType('radius', 'number', radius);
        ptCheckType('sides', 'number', sides);
        ptCheckType('color', 'string', color);

        drawPolygon(x, y, radius, sides, color);
        return;
    },

    drawCircle: function(result, x, y, diameter, color) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawCircle', args, 4, 4);
        ptCheckType('x', 'number', x);
        ptCheckType('y', 'number', y);
        ptCheckType('diameter', 'number', diameter);
        ptCheckType('color', 'string', color);
        drawCircle(x, y, diameter, color);
        return;
    },

    drawQuadrilateral: function(result, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawQuadrilateral', args, 9, 9);
        ptCheckType('x1', 'number', x1);
        ptCheckType('y1', 'number', y1);
        ptCheckType('x2', 'number', x2);
        ptCheckType('y2', 'number', y2);
        ptCheckType('x3', 'number', x3);
        ptCheckType('y3', 'number', y3);
        ptCheckType('x4', 'number', x4);
        ptCheckType('y4', 'number', y4);
        ptCheckType('color', 'string', color);

        drawQuadrilateral(x1, y1, x2, y2, x3, y3, x4, y4, color);
        return;
    },

    drawText: function(result, s, x, y, color, size, font) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('drawText', args, 3, 6);
        ptCheckType('s', 'string', s);
        ptCheckType('x', 'number', x);
        ptCheckType('y', 'number', y);
        if (color === undefined) {
            drawText(s, x, y); return;
        } else {
            ptCheckType('color', 'string', color);
        }
        if (size === undefined) {
            drawText(s, x, y, color); return;
        } else {
            ptCheckType('size', 'number', size);
        }
        if (font === undefined) {
            drawText(s, x, y, color, font); return;
        } else {
            ptCheckType('font', 'string', size);
        }

        drawText(s, x, y, color, size, font);
        return;
    },

    getCanvasWidth: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getCanvasWidth', args, 0, 0);
        return getCanvasWidth();
    },

    getCanvasHeight: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getCanvasHeight', args, 0, 0);
        return getCanvasHeight();
    },

    rgbToHex: function(result, r, g, b) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('rgbToHex', args, 3, 3);
        ptCheckType('r', 'number', r);
        ptCheckType('g', 'number', g);
        ptCheckType('b', 'number', b);
        return rgbToHex(r, g, b);
    },

    rgbaToHex: function(result, r, g, b, a) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('rgbaToHex', args, 4, 4);
        ptCheckType('r', 'number', r);
        ptCheckType('g', 'number', g);
        ptCheckType('b', 'number', b);
        ptCheckType('a', 'number', a);
        return rgbaToHex(r, g, b, a);
    },

    getNumberOfTracks: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getNumberOfTracks', args, 0, 0);
        return result.tracks.length;
    },

    getAmplitude: function(result, track) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getAmplitude', args, 1, 1);
        ptCheckType('track', 'number', track);
        return getAmplitude(track);
    },

    getRawAmplitude: function(result, track) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getRawAmplitude', args, 1, 1);
        ptCheckType('track', 'number', track);
        return getRawAmplitude(track);
    },

    getSmoothAmplitude: function(result, track) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getRawAmplitude', args, 1, 1);
        ptCheckType('track', 'number', track);
        return getSmoothAmplitude(track);
    },

    getBeat: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getBeat', args, 0, 0);
        return getBeat();
    },

    getCurrentMeasure: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getCurrentMeasure', args, 0, 0);
        return getCurrentMeasure();
    },

    getPreciseCurrentMeasure: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getPromiseCurrentMeasure', args, 0, 0);
        return getPreciseCurrentMeasure();
    },

    getCurrentTime: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getCurrentTime', args, 0, 0);
        return getCurrentTime();
    },

    getTempo: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getTempo', args, 0, 0);
        return result.tempo;
    },

    getMsSinceStart: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getMsSinceStart', args, 0, 0);
        return getMsSinceStart();
    },

    getTotalLengthInSeconds: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getTotalLengthInSeconds', args, 0, 0);
        return getTotalLengthInSeconds();
    },

    getTotalLengthInMeasures: function(result) {
        args = copyArgs(arguments).slice(1);
        ptCheckArgs('getTotalLengthInMeasures', args, 0, 0);
        return getTotalLengthInMeasures();
    }
}

function ptCheckArgs(funcName, arguments, required, optional) {
    var res = true;

    if (required == optional) {
        if (arguments.length != required) {
            res = funcName + '() takes exactly ' + required + ' argument(s) (' + arguments.length + ' given)';
        } else {
            res = true;
        }
    } else {
        if ((arguments.length >= required) &amp;&amp; (arguments.length &lt;= optional)) {
            res = true;
        } else if (arguments.length &lt; required) {
            res = funcName + '() takes at least ' + required + ' argument(s) (' + arguments.length + ' given)';
        } else {
            res = funcName + '() takes only ' + required + ' argument(s) (' + arguments.length + ' given)';
        }
    }

    if (res !== true) {
        throw new TypeError(res);
    }
}

function ptCheckType(name, exptype, arg) {
    var res = true;

    if (exptype === 'array') {
        if (arg.constructor !== Array) {
            res = name + ' must be a list';
        }
    } else if (exptype === 'boolean') {
        if (typeof(arg) !== exptype) {
            // for some reason Skulpt maps booleans to 1 or 0
            return arg === 1 || arg === 0;
        }
    } else {
        if (typeof(arg) !== exptype) {
            res = name + ' must be a ' + exptype;
        }
    }

    if (res !== true) {
        throw new TypeError(res);
    }
}

function ptCheckFilekeyType(filekey) {
    var res = true;

    if ((filekey[0] === "'" &amp;&amp; filekey[filekey.length-1] === "'") ||
        (filekey[0] === '"' &amp;&amp; filekey[filekey.length-1] === '"')) {
        res = 'Media constant (' + filekey + ') should not include quotation marks';
    }

    if (res !== true) {
        throw new TypeError(res);
    }
}

function ptCheckRange(name, arg, min, max) {
    var res = true;

    if (typeof(min) === 'number' &amp;&amp; typeof(max) === 'number') {
        if (arg &lt; min || arg > max) {
            res = name + ' exceeds the allowed range of ' + min + ' to ' + max;
        }
    } else if (typeof(min) === 'object') {
        // TODO: change the bad arg names...
        if (min.hasOwnProperty('min') &amp;&amp; min.hasOwnProperty('max')) {
            if (arg &lt; min.min || arg > min.max) {
                res = name + ' exceeds the allowed range of ' + min.min + ' to ' + min.max;
            }
        } else {
            if (min.hasOwnProperty('min')) {
                if (arg &lt; min.min) {
                    res = name + ' cannot be smaller than ' + min.min;
                }
            }

            if (min.hasOwnProperty('max')) {
                if (arg > min.max) {
                    res = name + ' cannot be bigger than ' + min.max;
                }
            }
        }
    }

    if (res !== true) {
        throw new RangeError(res);
    }
}

function ptCheckEffectRange(effectname, parameter, effectStartValue, effectStartLocation, effectEndValue, effectEndLocation) {
    var res = true;
    var effectObject = effectDefaults[effectname][parameter];

    if (effectStartValue !== undefined) {
        if (effectEndValue === undefined) {
            if ((effectObject.min &lt;= effectStartValue) &amp;&amp; (effectObject.max >= effectStartValue)) {
                res = true;
            } else {
                res = false;
            }
        } else if (effectEndValue !== undefined) {
            if (((effectObject.min &lt;= effectStartValue) &amp;&amp; (effectObject.max >= effectStartValue)) &amp;&amp;  ((effectObject.min &lt;= effectEndValue) &amp;&amp; (effectObject.max >= effectEndValue))) {
                res = true;
            } else {
                res = false;
            }
        }
    }

    if ((effectStartLocation !== undefined) &amp;&amp; ((effectEndLocation !== undefined) &amp;&amp; (effectEndLocation != 0))) {
        if (effectEndLocation &lt; effectStartLocation) {
            throw new RangeError(' Cannot have effect start measure greater than end measure');

        }
    }

    if (res !== true) {
        var error = new RangeError(parameter + ' is out of range');
        throw error;
    }
}

function copyArgs(args) {
    var result = [];
    for (var i = 0; i &lt; args.length; i++) {
        result.push(args[i]);
    }
    return result;
}

/**
 * Helper function to add clips to the result.
 *
 * @param {Object} result The result object to add the clip to.
 * @param {Object} clip The clip to add.
 * @param {string} clip.filekey The filekey to load in the clip.
 * @param {integer} clip.track The track to add the clip to.
 * @param {integer} clip.measure The measure to begin playing at.
 * @param {number} clip.start The start measure of the clip slice to play.
 * @param {number} clip.end The end measure of the clip slice to play.
 * @param {boolean} clip.scale Whether the clip should be scaled or not to
 * fill the space (not implemented).
 * @param {boolean} clip.loop Whether the clip should be loop or not to
 * fill the space.
 * @param {number} silence The length of silence after the clip used for
 * determining the length of the song (e.g., if makebeat has silence at the
 * end of the song).
 */
function addClip(result, clip, silence) {

    if (silence == undefined) {
        clip.silence = 0;
    } else {
        clip.silence = silence;
    }

    // bounds checking
    if (clip.track == 0) {
        throw new RangeError('Cannot insert media on the master track');
    }

    if (clip.track &lt; 0) {
        throw new RangeError('Cannot insert media before the first track');
    }

    if (clip.measure &lt; 1) {
        throw new RangeError('Cannot insert media before the first measure');
    }

    if (clip.end !== 0 &amp;&amp; clip.end &lt; clip.start) {
        throw new RangeError('Clip cannot end before it starts');
    }

    if (clip.end &lt; 0 || clip.start &lt; 0) {
        throw new RangeError('Clips cannot have negative start or end values');
    }

    // create the track if it does not exist
    while (clip.track >= result.tracks.length) {
        result.tracks.push({
            clips: [],
            effects: {}
        })
    }

    result.tracks[clip.track].clips.push(clip);
}

/**
 * Helper function to add effects to the result.
 */
function addEffect(result, effect) {
    esconsole(effect, 'debug');

    // bounds checking
    if (effect.track &lt; 0) {
        throw new RangeError('Cannot add effects before the first track');
    }
    if (effect.track > result.tracks.length-1) {
        //throw new RangeError('Cannot add effects after the last track');
        // TODO: instead of warning, we need post-compilation error checking
        var userConsole = ServiceWrapper().userConsole;
        userConsole.warn(
            ESMessages.dawservice.effecttrackwarning + ' (Track ' + effect.track + ')'
        );
    }

    if (effectDefaults[effect.name] === undefined) {
        throw new RangeError('Effect name does not exist');
    }
    if (effectDefaults[effect.name][effect.parameter] === undefined) {
        throw new RangeError('Effect parameter does not exist');
    }

    ptCheckEffectRange(
        effect.name, effect.parameter, effect.startValue,
        effect.startMeasure, effect.endValue, effect.endMeasure
    );

    // create the track if it does not exist
    while (effect.track >= result.tracks.length) {
        result.tracks.push({
            clips: [],
            effects: {}
        })
    }

    var key = effect.name + '-' + effect.parameter;

    // create the effect list if it does not exist
    if (result.tracks[effect.track].effects[key] == undefined) {
        result.tracks[effect.track].effects[key] = [];
    }

    // TODO: this should happen when the effect is applied, not
    // now. But until applyeffects.js gets refactored, this will have to
    // do.
    //
    // Scale the effect ranges from user-inputted values to WebAudio
    // accepted ranges.
    var scaledRange = scaleEffect(
        effect.name, effect.parameter, effect.startValue, effect.endValue
    );
    effect.inputStartValue = effect.startValue;
    effect.startValue = scaledRange[0];
    effect.inputEndValue = effect.endValue;
    effect.endValue = scaledRange[1];

    result.tracks[effect.track].effects[key].push(effect);
}


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-accountController.html">accountController</a></li><li><a href="module-Analyze.html">Analyze</a></li><li><a href="module-apibrowserController.html">apibrowserController</a></li><li><a href="module-audioContext.html">audioContext</a></li><li><a href="module-audioeffects.html">audioeffects</a></li><li><a href="module-audioLibrary.html">audioLibrary</a></li><li><a href="module-autograderController.html">autograderController</a></li><li><a href="module-buildAudioNodeGraph.html">buildAudioNodeGraph</a></li><li><a href="module-changepasswordController.html">changepasswordController</a></li><li><a href="module-ColorPickerCtrl.html">ColorPickerCtrl</a></li><li><a href="module-compiler.html">compiler</a></li><li><a href="module-dawClip.html">dawClip</a></li><li><a href="module-dawClipName.html">dawClipName</a></li><li><a href="module-dawContainerController.html">dawContainerController</a></li><li><a href="module-dawController.html">dawController</a></li><li><a href="module-dawEffect.html">dawEffect</a></li><li><a href="module-dawTimeline.html">dawTimeline</a></li><li><a href="module-dawTrackController.html">dawTrackController</a></li><li><a href="module-DownloadFileCtrl.html">DownloadFileCtrl</a></li><li><a href="module-EarSketchApp.html">EarSketchApp</a></li><li><a href="module-forgotpasswordController.html">forgotpasswordController</a></li><li><a href="module-ideController.html">ideController</a></li><li><a href="module-JavascriptAPI.html">JavascriptAPI</a></li><li><a href="module-mainController.html">mainController</a></li><li><a href="module-NativeJavascriptAPI.html">NativeJavascriptAPI</a></li><li><a href="module-Passthrough.html">Passthrough</a></li><li><a href="module-pitchshifter.html">pitchshifter</a></li><li><a href="module-player.html">player</a></li><li><a href="module-PythonAPI.html">PythonAPI</a></li><li><a href="module-renameController.html">renameController</a></li><li><a href="module-renderer.html">renderer</a></li><li><a href="module-ReportErrorCtrl.html">ReportErrorCtrl</a></li><li><a href="module-SaveScriptCtrl.html">SaveScriptCtrl</a></li><li><a href="module-uploader.html">uploader</a></li><li><a href="module-userConsole.html">userConsole</a></li><li><a href="module-userNotification.html">userNotification</a></li><li><a href="module-WaveforrmCache.html">WaveforrmCache</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addESTagToLog">addESTagToLog</a></li><li><a href="global.html#addESTagToNotLog">addESTagToNotLog</a></li><li><a href="global.html#addESTagToNotPrint">addESTagToNotPrint</a></li><li><a href="global.html#addESTagToPrint">addESTagToPrint</a></li><li><a href="global.html#esconsole">esconsole</a></li><li><a href="global.html#ESLog">ESLog</a></li><li><a href="global.html#formatResultForTests">formatResultForTests</a></li><li><a href="global.html#formatScriptForTests">formatScriptForTests</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#ServiceWrapper">ServiceWrapper</a></li><li><a href="global.html#setESConsoleTraceLevel">setESConsoleTraceLevel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Feb 11 2016 16:06:08 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
