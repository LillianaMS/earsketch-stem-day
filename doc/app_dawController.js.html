<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app/dawController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app/dawController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Angular directive / controller for the DAW view. Members can be accessed with $scope.name from within JS, or just name from within HTML that is bound to this controller.
 * @module dawController
 */
app.directive('daw', function() {
    return {
        templateUrl: 'templates/daw-view.html',
        transclude: true,
        controller: ['$scope', '$timeout', 'player', 'audioContext', function ($scope, $timeout, player, context) {

            $scope.horzZoomLevels = [700, 2100, 3500, 6000, 7000, 8000, 8500, 9000, 9500, 10000];
            $scope.vertZoomLevels = [28, 35, 45, 55, 65, 75, 85, 95, 115, 125];
            $scope.horzZoom = 0;
            $scope.vertZoom = 2;

            $scope.trackWidth = $scope.horzZoomLevels[$scope.horzZoom]; // track width when the scale is 1
            $scope.trackHeight = $scope.vertZoomLevels[$scope.vertZoom]; // track height when the scale is 1

            /**
             * Size of track control box
             * @type {number}
             */
            $scope.xOffset = 100;

            /**
             * @name volume
             * @type {number} in dB
             */
            $scope.volume = 0; //dB

            /**
             * The master volume mute control.
             * @name volumeMuted
             * @type {boolean} Default = false
             */
            $scope.volumeMuted = false;

            /**
             * @name playing
             * @type {boolean}
             */
            $scope.playing = false;
            $scope.daw_timelineOffset = 100;

            /**
             * Current play position in measures - starts at 1
             * @name playPosition
             * @type {number}
             */
            $scope.playPosition = 1;

            /**
             * These flags are meant to preserve muted and solo tracks when a script is rerun for live coding. It has to be an object because setting a value in a child scope only updates the local scope, but we need to update the parent scope.
             * @name preserve
             * @type {{solo: Array, muted: Array, bypass: Array, metronome: boolean, effects: boolean}}
             */
            $scope.preserve = {
                'solo': [],
                'muted': [],
                'bypass': [],
                'metronome': false,
                'effects': true
            };

            /**
             * Loop selected sections
             * @type {{selection: boolean, start: number, end: number, on: boolean, reset: boolean}}
             */
            $scope.loop = {
                'selection': false, // false=loop whole track
                'start': 1,
                'end': 1,
                'on': false, // true=enable looping
                'reset': false
            };

            /**
             * @name tracks
             * @type {Array}
             */
            $scope.tracks = [];

            $scope.result = null;

            // everything in here gets reset when a new project is loaded
            // Listen for the IDE to compile code and return a JSON result
            $scope.$on('compiled', function(event, result) {

                var restart = false;
                if ($scope.playing) {
                    // pause the current result before overwriting
                    $scope.pause();
                    restart = true;
                }

                // overwrite the current script result
                $scope.result = result;

                if (restart) {
                    // begin playing the new result immediately
                    $scope.play();
                }

                $scope.vertScrollPos = 0;
                $scope.horzScrollPos = 0;

                // this is the measure number where the script ends
                $scope.playLength = result.length + 1;

                $scope.tempo = result.tempo;

                $scope.tracks = result.tracks;
                for (var i in $scope.tracks) {
                    var track = $scope.tracks[i];

                    track.visible = true;
                    track.solo = $scope.preserve.solo.indexOf(i) > -1;
                    track.mute = $scope.preserve.muted.indexOf(i) > -1;
                    track.label = i
                    track.buttons = true; // show solo/mute buttons

                    for (var j in track.effects) {
                        var effect = track.effects[j];
                        effect.visible = $scope.preserve.effects;
                        effect.bypass = $scope.preserve.bypass.indexOf(j) > -1;
                    }
                }
                $scope.master = $scope.tracks[0];
                $scope.metronome = $scope.tracks[$scope.tracks.length-1];

                $scope.xScale = d3.scale.linear()
                                .domain([1, $scope.playLength]) // measures start at 1
                                .range([0, $scope.trackWidth]);

                // sanity checks
                if ($scope.loop.start > $scope.playLength) {
                    $scope.loop.start = 1;
                }
                if ($scope.loop.end > $scope.playLength) {
                    $scope.loop.end = $scope.playLength;
                }

                if (typeof $scope.master !== "undefined") {
                    var effects = $scope.master.effects;
                    var num = Object.keys(effects).length;
                    $scope.master.visible = num > 0;
                    $scope.master.mute = false;
                    // the master track is special
                    $scope.master.label = 'Master';
                    $scope.master.buttons = false;
                }
                if (typeof $scope.metronome !== "undefined") {
                    $scope.metronome.visible = false;
                    $scope.metronome.mute = !$scope.preserve.metronome;
                    $scope.metronome.effects = {};
                }

            });

            /**
             * @name play
             * @function
             */
            $scope.play = function() {
                $scope.pause();
                $scope.playing = true;

                // reset play position to beginning at end of song
                if ($scope.playPosition >= $scope.playLength) {
                    $scope.playPosition = 1;
                }

                var startTime =
                    ESUtilsMeasureToTime($scope.playPosition, $scope.tempo);

                // handle loop selections
                if ($scope.loop.selection &amp;&amp; $scope.loop.on) {
                    var loopStart =
                        ESUtilsMeasureToTime($scope.loop.start, $scope.tempo);
                    if (startTime &lt; loopStart) {
                        startTime = loopStart;
                    }
                }

                // create a list of muted tracks and
                // bypassed effects for each track
                bypassedEffects = [];
                mutedTracks = []
                for (var i = 0; i &lt; $scope.tracks.length; i++) {
                    var track = $scope.tracks[i];
                    if (track.mute) {
                        mutedTracks.push(i);
                    }
                    var trackBypass = [];
                    for (var key in track.effects) {
                        var effect = track.effects[key];
                        if (effect.bypass) {
                            trackBypass.push(key);
                        }
                    }
                    bypassedEffects.push(trackBypass);
                }

                // play the script
                player.playResult(
                    $scope.result, startTime, mutedTracks, bypassedEffects
                );
                // volume state is not preserved between plays
                if ($scope.volumeMuted) {
                    $scope.mute();
                } else {
                    $scope.changeVolume();
                }

                // current context time is not going to be 0
                var timeOffset = context.currentTime;

                // pick up the current audio cursor position

                var interval = 30; // milli
                $scope.audioTimer = setInterval(function(){
                    $scope.$apply(function() {

                        // remember that measures start at 1
                        $scope.playPosition = 1 + ESUtilsTimeToMeasure(
                            context.currentTime
                            - timeOffset
                            + startTime,
                            $scope.tempo);

                        if($scope.playPosition > $scope.playLength){
                            // clear timer when project finishes
                            clearInterval($scope.audioTimer);
                            $scope.pause();

                            // looping is enabled
                            if($scope.loop.on) {
                                $scope.playPosition = 1;
                                $scope.play();
                            } else {
                                $scope.playPosition = $scope.playLength;
                            }
                        } else if ($scope.loop.on &amp;&amp;
                                   $scope.loop.selection &amp;&amp;
                                   $scope.playPosition > $scope.loop.end
                        ) {
                            clearInterval($scope.audioTimer);
                            $scope.playing = false;
                            $scope.playPosition = $scope.loop.start;

                            // looping is enabled
                            if($scope.loop.on) {
                                $scope.play();
                            }
                        }
                    });
                }, interval); // smaller interval -> smoother line movement

                __ES_RESULT = $scope.result; // for P5 only

                // TODO: refactor P5 integration
                //Compiling canvas variables and p5 init on Run
                canvas_compile();
                canvas_play();
            };

            $scope.pause = function() {
                player.pauseResult($scope.result);

                if(typeof($scope.audioTimer) !== "undefined"){
                    clearInterval($scope.audioTimer);
                }
                $scope.playing = false;

                canvas_pause();
            };

            $scope.forward = function(measures) {
                $scope.playPosition = $scope.playPosition + measures;
                if ($scope.playPosition > $scope.playLength) {
                    $scope.playPosition = $scope.playLength;
                }
                // replay to update current play time
                if ($scope.playing) {
                    $scope.play();
                }
            };

            $scope.backward = function(measures) {
                $scope.playPosition = $scope.playPosition - measures;
                if ($scope.playPosition &lt; 1) {
                    $scope.playPosition = 1;
                }
                // replay to update current play time
                if ($scope.playing) {
                    $scope.play();
                }
            };

            $scope.reset = function() {
                $scope.playPosition = 1;
                // replay to update current play time
                if ($scope.playing) {
                    $scope.play();
                }
            };

            $scope.toggleMetronome = function() {
                if (typeof($scope.metronome) !== 'undefined') {
                    $scope.metronome.mute = !$scope.metronome.mute;
                    $scope.preserve.metronome = !$scope.metronome.mute;
                    if ($scope.playing) {
                        $scope.play();
                    }
                }
            };

            $scope.toggleMute = function () {
                if (!$scope.volumeMuted) {
                    $scope.mute();
                } else {
                    $scope.unmute();
                }
            };

            $scope.mute = function() {
                $scope.volumeMuted = true;
                player.setVolume($scope.result, -60);
            }

            $scope.unmute = function() {
                $scope.volumeMuted = false;
                player.setVolume($scope.result, $scope.volume);
            }

            $scope.changeVolume = function() {
                $timeout(function() {
                    $scope.unmute();
                    player.setVolume($scope.result, $scope.volume);
                }, 0);
            };

            $scope.hasEffects = function() {
                for (var n in $scope.tracks) {
                    if (Object.keys($scope.tracks[n]).length > 0) {
                        return true;
                    }
                }
                return false;
             };

            $scope.hasInvisibleEffects = function() {
                for (var n in $scope.tracks) {
                    for (var key in $scope.tracks[n].effects) {
                        if (!$scope.tracks[n].effects[key].visible) {
                            return true;
                        }
                    }
                }
                return false;
            }

            $scope.toggleEffects = function() {
                var visibility = $scope.hasInvisibleEffects();
                for (var n in $scope.tracks) {
                    for (var key in $scope.tracks[n].effects) {
                        $scope.tracks[n].effects[key].visible = visibility;
                    }
                }
                $scope.preserve.effects = visibility;
            };

            $scope.muteTrack = function(num) {
                esconsole('Muting track ' + num, ['DEBUG', 'DAW']);
                $scope.tracks[num].mute = true;
                // preserve mute status
                if ($scope.preserve.muted.indexOf(num) &lt; 0) {
                    $scope.preserve.muted.push(num);
                }
                player.muteTrack($scope.result, num);
            };

            $scope.unmuteTrack = function(num) {
                esconsole('Unmuting track ' + num, ['DEBUG', 'DAW']);
                $scope.tracks[num].mute = false;
                // preserve mute status
                if ($scope.preserve.muted.indexOf(num) >= 0) {
                    $scope.preserve.muted.splice(
                        $scope.preserve.muted.indexOf(num)
                    , 1);
                }
                player.unmuteTrack($scope.result, num);
            };

            $scope.soloTrack = function(num) {
                $scope.tracks[num].solo = true;
                // preserve solo status
                if ($scope.preserve.solo.indexOf(num) &lt; 0) {
                    $scope.preserve.solo.push(num);
                }
                for (var i = 0; i &lt; $scope.tracks.length; i++) {
                    $scope.muteTrack(num);
                }
                for (var j = 0; j &lt; $scope.preserve.solo.length; j++) {
                    $scope.unmuteTrack($scope.preserve.solo[j]);
                }
            };

            $scope.unsoloTrack = function(num) {
                $scope.tracks[num].solo = false;
                // preserve mute status
                if ($scope.preserve.solo.indexOf(num) >= 0) {
                    $scope.preserve.solo.splice(
                        $scope.preserve.solo.indexOf(num)
                    , 1);
                }

                if ($scope.preserve.solo.length === 0) {
                    for (var i = 0; i &lt; $scope.tracks.length; i++) {
                        $scope.unmuteTrack(i);
                    }
                } else {
                    for (var i = 0; i &lt; $scope.tracks.length; i++) {
                        $scope.muteTrack(i);
                    }
                    for (var j = 0; j &lt; $scope.preserve.solo.length; j++) {
                        $scope.muteTrack($scope.preserve.solo[j]);
                    }
                }
            };

            $scope.hasSoloTracks = function() {
                for (var i in $scope.tracks) {
                    if ($scope.tracks[i].solo) {
                        return true;
                    }
                }
                return false;
            };

            // update scale when track width changes
            $scope.$watch(function() { return $scope.trackWidth; }, function() {
                $scope.xScale = d3.scale.linear()
                                // measures start at 1
                                .domain([1, $scope.playLength])
                                .range([0, $scope.trackWidth]);
            });
        }],
        link: function(scope, element, attrs) {
            // listen for new scripts to reset the tracks
            scope.$on('renderDaw', scope.update);
        }
    }
});

/**
 * Angular directive / controller for the whole DAW container.
 * @module dawContainerController
 */
app.directive('dawContainer', function() {
    return {
        require: '^daw',
        controller: function($scope) {
            // enable math functions in angular bindings (TODO: why don't we wrap in an injectable service?)
            $scope.Math = Math;

            /**
             * @name moveBar
             * @function
             * @param event {object}
             */
            $scope.moveBar = function(event) {
                // calculate x position of the bar from mouse position
                var target = angular.element(event.currentTarget);
                var xpos = event.clientX - target.offset().left;
                if(target[0].className != "daw-track")
                    xpos = xpos -  $scope.daw_timelineOffset;

                // round to the nearest measure
                var measure = Math.round($scope.xScale.invert(xpos));
                // ensure position is within bounds
                if (xpos >= 0 &amp;&amp; measure &lt;= $scope.playLength) {
                    $scope.playPosition = measure;
                }
                // replay to update current play time
                if ($scope.playing) {
                    $scope.play();
                }
            };

            // select looping sections
            $scope.dragging = false;
            $scope.cursorPosition = 0;

            /**
             * @name getCurrentPlayPositionInMeasures
             * @function
             * @returns {number}
             */
            $scope.getCurrentPlayPositionInMeasures = function () {
                return $scope.playPosition;
            };

            /**
             * @name getCurrentPlayPositionInSeconds
             * @function
             * @returns {number}
             */
            $scope.getCurrentPlayPositionInSeconds = function () {
                return ESUtilsMeasureToTime($scope.playPosition, $scope.tempo);
            };

            /**
             * @name startDrag
             * @function
             * @param event {object}
             */
            $scope.startDrag = function(event) {
                event.preventDefault();
                // calculate x position of the bar from mouse position
                var target = angular.element(event.currentTarget);
                var xpos = event.clientX - target.offset().left;
                if(target[0].className != "daw-track")
                    xpos = xpos -  $scope.daw_timelineOffset;

                // allow clicking the track controls without affecting dragging
                if (xpos &lt; $scope.horzScrollPos) {
                    return;
                }

                $scope.dragging = true;

                // keep track of what state to revert to if looping is canceled
                $scope.loop.reset = $scope.loop.on;
                // round to nearest beat
                var measure = Math.round($scope.xScale.invert(xpos));

                //Do not drag if beyond playLength
                if(measure > $scope.playLength){
                    $scope.dragging = false;
                    return;
                }

                $scope.loop.start = measure;
                $scope.loop.end = measure;
            };

            /**
             * @name endDrag
             * @function
             * @param event {object}
             */
            $scope.endDrag = function(event) {
                event.preventDefault();
                // calculate x position of the bar from mouse position
                var target = angular.element(event.currentTarget);
                var xpos = event.clientX - target.offset().left;
                if(target[0].className != "daw-track")
                    xpos = xpos -  $scope.daw_timelineOffset;

                if (!$scope.dragging) {
                    return;
                }

                // round to nearest measure
                var measure = Math.round($scope.xScale.invert(xpos));

                // Force measure to be playlength if greater
                if(measure > $scope.playLength){
                    measure = $scope.playLength;
                }

                $scope.dragging = false;
                $scope.loop.end = measure;
                // loop this selection
                $scope.loop.selection = true;

                if ($scope.loop.end - $scope.loop.start == 0) {
                    // turn looping off if the loop range is 0 (i.e., no drag)
                    $scope.loop.selection = false;
                    $scope.loop.on = $scope.loop.reset;
                } else { //($scope.loop.end - $scope.loop.start &lt; 0) {
                    // swap start and end if dragging backwards
                    var temp = $scope.loop.start;
                    $scope.loop.start = Math.min(temp, $scope.loop.end);
                    $scope.loop.end = Math.max(temp, $scope.loop.end);
                    // enable looping automatically
                    $scope.loop.on = true;
                }

                if ($scope.playing) {
                    $scope.play();
                }
            };

            /**
             * @name drag
             * @function
             * @param event {object}
             */
            $scope.drag = function(event) {
                event.preventDefault();
                // calculate x position of the bar from mouse position
                var target = angular.element(event.currentTarget);
                var xpos = event.clientX - target.offset().left;
                if(target[0].className != "daw-track")
                    xpos = xpos -  $scope.daw_timelineOffset;
                // round to nearest measure
                var measure = Math.round($scope.xScale.invert(xpos));

                if (measure &lt;= $scope.playLength &amp;&amp; measure > 0) {
                    $scope.cursorPosition = $scope.xScale(measure);
                }

                // Prevent dragging beyond playLength
                if(measure > $scope.playLength){
                    return;
                }

                if ($scope.dragging) {
                    $scope.loop.end = measure;
                }
            };

            $scope.$watch(function() { return $scope.horzZoom; }, function() {
                $scope.trackWidth = $scope.horzZoomLevels[$scope.horzZoom];
            });

            $scope.$watch(function() { return $scope.vertZoom; }, function() {
                $scope.trackHeight = $scope.vertZoomLevels[$scope.vertZoom];
            });
        },
        link: function(scope, element, attr) {
            // update scroll positions
            element.bind('scroll', function(e) {
                scope.vertScrollPos = e.target.scrollTop;
                scope.horzScrollPos = e.target.scrollLeft;
                scope.$apply(); // update angular scope
            });

            // autoscroll the daw
            scope.$watch(function() { return scope.playPosition; }, function() {
                if ($("#zoom-container").is(":visible") &amp;&amp; innerLayout.north.state.isVisible) {
                    // last measure visible to the user in the daw view
                    var viewMin = scope.xScale.invert(
                        scope.horzScrollPos - scope.xOffset
                    );
                    var viewMax = scope.xScale.invert(
                        scope.horzScrollPos + element.width() - scope.xOffset
                    );
                    // autoscroll right
                    if (scope.playPosition > viewMax) {
                        element[0].scrollLeft += element.width() - scope.xOffset;
                        scope.horzScrollPos += element.width() - scope.xOffset;
                    // autoscroll left
                    } else if (scope.playPosition &lt; viewMin) {
                        var jump = scope.xScale(scope.playPosition);
                        element[0].scrollLeft = jump;
                        scope.horzScrollPos = jump;
                    }
                }
            });
        }
    }
});

/**
 * Angular directive / controller for the DAW timeline element.
 * @module dawTimeline
 */
app.directive('dawTimeline', function() {
    return {
        require: '^daw',
        link: function(scope, element, attr) {

            // append svg element
            var svg = d3.select(element[0]).append('svg')
                .attr('class', 'axis')
                .append('g');

            scope.$watch(function() { return scope.vertScrollPos; }, function(oldValue, newValue) {
                element.css("top", scope.vertScrollPos + 'px');
            });

            // redraw the timeline when the track width changes
            scope.$watch(function() { return scope.xScale; }, function(oldValue, newValue) {
                element.css("width", scope.xOffset + scope.xScale(scope.playLength+1) + 'px');  // scale to correct width

                // this formula was arbitrarily determined to do well for scaling
                // the tick intervals in the timeline based on song length and
                // zoom level
                var measures = scope.playLength;
                var measures2 = Math.pow(2, Math.round(Math.log2(measures)));
                var width2 = Math.pow(2, Math.round(Math.log2(element.width())));
                var labelInterval = Math.round(Math.max(1,measures2*(measures2/width2)/2));
                var tickInterval = labelInterval / 4.0;

                // add tick intervals
                ticks = [];
                for (i=0; i &lt;= scope.playLength; i += tickInterval) {
                    ticks.push(i)
                }

                // create d3 axis
                var timeline = d3.svg.axis()
                    .scale(scope.xScale) // scale ticks according to zoom
                    .orient("bottom")
                    //.ticks(scope.trackWidth/50)
                    .tickValues(ticks)
                    //.tickFormat(d3.format("1.0f"));
                    .tickFormat(function(d) {
                        if (d%labelInterval !== 0) {
                            return '';
                        } else {
                            return d;
                        }
                    });

                // append axis to timeline dom element
                d3.select(element[0]).select('svg.axis g')
                    .call(timeline)
                    .selectAll("text")
                    // move the first text element to fit inside the view
                    .style("text-anchor", "start")
            });

        }
    }
});

/**
 * Angular directive / controller for each DAW track
 * @module dawTrackController
 */
app.directive('dawTrack', function() {
    return {
        require: '^daw',
        templateUrl: 'templates/daw-track.html',
        transclude: true,
        controller: function($scope) {

            /**
             * @name toggleSolo
             * @function
             */
            $scope.toggleSolo = function() {
                var temp = $scope.metronome.mute;

                if (!$scope.track.solo) {
                    // solo

                    for (var i in $scope.tracks) {
                        // TODO: why is this a string...?
                        i = parseInt(i);
                        // mute tracks that are not soloed
                        if (!$scope.tracks[i].solo) {
                            $scope.muteTrack(i);
                        }
                    }
                    // unmute and solo this track
                    $scope.unmuteTrack($scope.trackNum);
                    $scope.soloTrack($scope.trackNum)
                } else {
                    // unsolo

                    $scope.unsoloTrack($scope.trackNum);

                    if ($scope.hasSoloTracks()) {
                        $scope.muteTrack($scope.trackNum);
                    } else {
                        for (var i in $scope.tracks) {
                            // TODO: why is this a string...?
                            i = parseInt(i);
                            $scope.unmuteTrack(i);
                        }
                    }

                }
                // master and metronome are unaffected
                $scope.master.mute = false;
                $scope.metronome.mute = temp;

                if ($scope.playing) {
                    $scope.play();
                }
            };

            /**
             * @name toggleMute
             * @function
             */
            $scope.toggleMute = function() {
                var temp = $scope.metronome.mute;

                if ($scope.track.mute) {
                    $scope.unmuteTrack($scope.trackNum);
                } else {
                    $scope.muteTrack($scope.trackNum);

                    if ($scope.track.solo) {
                        $scope.unsoloTrack($scope.trackNum);
                    }
                }

                // master and metronome are unaffected
                $scope.master.mute = false;
                $scope.metronome.mute = temp;

                if ($scope.playing) {
                    $scope.play();
                }
            }

        },
        link: function(scope, element, attr) {
            // scale width to zoom amount
            scope.$watch(function() { return scope.xScale; }, function(oldValue, newValue) {
                element.css('width',
                    scope.xOffset + scope.xScale(scope.playLength+1) + 'px'
                );
            });
        }
    }
});

/**
 * Angular directive / controller for each DAW clip
 * @module dawClip
 */
app.directive('dawClip', ['audioLibrary', 'WaveformCache',
              function(audioLibrary, WaveformCache) {
    return {
        require: '^daw',
        link: function(scope, element, attr) {
            function findPeak(waveform) {
                var peak = 0;
                for (var i = 0; i &lt; waveform.length; i++) {
                    if (Math.abs(waveform[i]) > Math.abs(peak)) {
                        peak = waveform[i];
                    }
                }

                return peak;
            }

            function getAverage(waveform) {
                return waveform.reduce(
                    function(a,b) {return a+b;}, 0
                ) / waveform.length;
            }

            function downSampleWithPeaks(audioSamples, divisor) {
                var res = [];

                var limit = Math.round(audioSamples.length/divisor)-1;
                for (var i = 0; i &lt; limit; i++) {
                    var sub = audioSamples.subarray(i*divisor, (i+1)*divisor);
                    res.push(findPeak(sub));
                }
                return res;
            }

            function getClipWaveform(buffer, width, clip) {
                var res = [];
                var chData = getClipAudioSamples(
                    buffer.getChannelData(0),
                    ESUtilsTimeToMeasure(buffer.duration, scope.tempo),
                    clip.start,
                    clip.end,
                    !clip.loop
                );

                chData = downSampleWithPeaks(
                    chData, Math.round(buffer.length/width/4)
                );

                var chunk; // temp array for averaging
                var delta = Math.round(chData.length / width);

                for (var i = 0; i &lt; width-1; i++) {
                    chunk = chData.slice(i * delta, (i+1) * delta);
                    res.push(getAverage(chunk));
                }

                chunk = chData.slice(i * delta, chData.length);
                res.push(getAverage(chunk));
                return res;
            }

            function drawWaveformOnCanvas(element, waveform, width, height) {
                var cvs = d3.select(element[0]).select('canvas')
                    .attr('width', width)
                    .attr('height', height);
                var ctx = cvs.node().getContext('2d');
                ctx.strokeStyle = '#427EB0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, (1-(waveform[0]+1)/2) * height);

                for (var i = 1; i &lt; waveform.length; i++) {
                    ctx.lineTo(i, (1-(waveform[i]+1)/2) * height);
                }

                ctx.stroke();
                ctx.closePath();
            }

            // scale width to zoom amount
            scope.$watch(function() { return scope.xScale; }, function(oldValue, newValue) {
                // calculate display width
                var clipWidth = scope.xScale(
                    scope.clip.end - scope.clip.start + 1
                );
                // adjust size and position of the clip based on scale
                element.css('width', clipWidth + 'px');
                // position clip at start location
                element.css('left', scope.xScale(
                    scope.clip.measure
                ) + 'px');

                var waveform = [];
                var idxIfExists = WaveformCache.checkIfExists(scope.clip, clipWidth);

                if (idxIfExists > -1) {
                    waveform = WaveformCache.get(idxIfExists);
                } else {
                    waveform = getClipWaveform(scope.clip.audio, clipWidth, scope.clip);
                    WaveformCache.add(scope.clip, clipWidth, waveform);
                }

                drawWaveformOnCanvas(element, waveform, clipWidth, scope.trackHeight);
            });

            // scale height to zoom amount
            scope.$watch(function() {return scope.trackHeight; }, function(oldValue, newValue) {
                // calculate display width
                var clipWidth = scope.xScale(
                    scope.clip.end - scope.clip.start + 1
                );

                var waveform = [];
                var idxIfExists = WaveformCache.checkIfExists(scope.clip, clipWidth);
                if (idxIfExists > -1) {
                    waveform = WaveformCache.get(idxIfExists);
                } else {
                    waveform = getClipWaveform(scope.clip.audio, clipWidth, scope.clip);
                    WaveformCache.add(scope.clip, clipWidth, waveform);
                }

                drawWaveformOnCanvas(element, waveform, clipWidth, scope.trackHeight);
            });

            // TODO: new feature: get tooltips working for clips to show buffer key and line of code that create it
        }
    }
}]);

/**
 * Angular directive for the daw clip name element
 * @module dawClipName
 */
app.directive('dawClipName', function() {
    return {
        require: '^daw',
        link: function(scope, element, attr) {
            scope.$watch(function() { return scope.xScale; }, function(oldValue, newValue) {
                var clipWidth = scope.xScale(
                    scope.clip.end - scope.clip.start + 1
                );
                // adjust size and position of the clip based on scale
                element.css('width', clipWidth + 'px');
            });
        }
    };
});

/**
 * Angular directive / controller for the DAW Effect tracks
 * @module dawEffect
 */
app.directive('dawEffect', function() {

    return {
        require: '^daw',
        controller: function($scope) {

            $scope.toggleBypass = function() {
                var i = $scope.effect[0].track +
                        $scope.effect[0].name +
                        $scope.effect[0].parameter;

                if ($scope.effect.bypass) {
                    $scope.effect.bypass = false;
                    // update preservation values
                    if ($scope.preserve.bypass.indexOf(i) >= 0) {
                        $scope.preserve.bypass.splice(
                            $scope.preserve.bypass.indexOf(i)
                        , 1);
                    }
                } else {
                    $scope.effect.bypass = true;
                    // update preservation values
                    if ($scope.preserve.bypass.indexOf(i) &lt; 0) {
                        $scope.preserve.bypass.push(i);
                    }
                }

                if ($scope.playing) {
                    $scope.play();
                }
            }
        },
        link: function(scope, element, attr) {

            // helper function to build a d3 plot of the effect
            function drawEffectWaveform() {
                var points = [];
                for (var i = 0; i &lt; scope.effect.length; i++) {
                    var range = scope.effect[i];
                    points.push({
                        x: range.startMeasure,
                        y: range.inputStartValue
                    });
                    points.push({
                        x: range.endMeasure,
                        y: range.inputEndValue
                    });
                }
                // draw a line to the end
                points.push({
                    x: scope.playLength + 1,
                    y: points[points.length - 1].y
                });
                // This sorting sometimes causes the ramp boundaries to be mixed up. For now, we sort them beforehand in fixClips() in compiler.js;
                //points.sort(function (a, b) {
                //    return a.x - b.x;
                //});

                var defaults = effectDefaults[scope.effect[0].name]
                    [scope.effect[0].parameter];

                var x = d3.scale.linear()
                    .domain([1, scope.playLength + 1])
                    .range([0, scope.xScale(scope.playLength + 1)]);
                var y = d3.scale.linear()
                    .domain([defaults.min, defaults.max])
                    .range([scope.trackHeight - 5, 5]);

                // map (x,y) pairs into a line
                var line = d3.svg.line().interpolate("linear")
                    .x(function (d, i) {
                        return x(d.x);
                    })
                    .y(function (d, i) {
                        return y(d.y);
                    });

                return line(points);
            }

            scope.$watch(function() { return scope.xScale; }, function(oldValue, newValue) {
                // scale width to zoom amount
                element.css('width', scope.xScale(
                    scope.playLength + 1
                ) + 'px');

                // update SVG waveform
                d3.select(element[0])
                    .select("svg.effectSvg")
                    .select("path")
                    .attr("d", drawEffectWaveform());
            });

            // scale height to zoom amount TODO: don't redraw the SVG every time
            scope.$watch(function() { return scope.trackHeight; }, function(oldValue, newValue) {

                // update SVG waveform
                d3.select(element[0])
                    .select("svg.effectSvg")
                    .select("path")
                    .attr("d", drawEffectWaveform());

                var parameter = effectDefaults[scope.effect[0].name][scope.effect[0].parameter]

                var yScale = d3.scale.linear()
                    .domain([parameter.max, parameter.min])
                    .range([0, scope.trackHeight]);

                var axis = d3.svg.axis()
                           .scale(yScale)
                           .orient('right')
                           .tickValues([parameter.max, parameter.min])
                           .tickFormat(d3.format("1.1f"));

                d3.select(element[0]).select('svg.effectAxis g')
                    .call(axis)
                    .select('text').attr('transform','translate(0,10)')

                // move the bottom label with this atrocious mess
                d3.select(d3.select(element[0]).select('svg.effectAxis g')
                   .selectAll('text')[0][1]).attr('transform', 'translate(0,-10)');
            });
        }
    };

});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-accountController.html">accountController</a></li><li><a href="module-Analyze.html">Analyze</a></li><li><a href="module-apibrowserController.html">apibrowserController</a></li><li><a href="module-audioContext.html">audioContext</a></li><li><a href="module-audioeffects.html">audioeffects</a></li><li><a href="module-audioLibrary.html">audioLibrary</a></li><li><a href="module-autograderController.html">autograderController</a></li><li><a href="module-buildAudioNodeGraph.html">buildAudioNodeGraph</a></li><li><a href="module-changepasswordController.html">changepasswordController</a></li><li><a href="module-ColorPickerCtrl.html">ColorPickerCtrl</a></li><li><a href="module-compiler.html">compiler</a></li><li><a href="module-dawClip.html">dawClip</a></li><li><a href="module-dawClipName.html">dawClipName</a></li><li><a href="module-dawContainerController.html">dawContainerController</a></li><li><a href="module-dawController.html">dawController</a></li><li><a href="module-dawEffect.html">dawEffect</a></li><li><a href="module-dawTimeline.html">dawTimeline</a></li><li><a href="module-dawTrackController.html">dawTrackController</a></li><li><a href="module-DownloadFileCtrl.html">DownloadFileCtrl</a></li><li><a href="module-EarSketchApp.html">EarSketchApp</a></li><li><a href="module-forgotpasswordController.html">forgotpasswordController</a></li><li><a href="module-ideController.html">ideController</a></li><li><a href="module-JavascriptAPI.html">JavascriptAPI</a></li><li><a href="module-mainController.html">mainController</a></li><li><a href="module-NativeJavascriptAPI.html">NativeJavascriptAPI</a></li><li><a href="module-Passthrough.html">Passthrough</a></li><li><a href="module-pitchshifter.html">pitchshifter</a></li><li><a href="module-player.html">player</a></li><li><a href="module-PythonAPI.html">PythonAPI</a></li><li><a href="module-renameController.html">renameController</a></li><li><a href="module-renderer.html">renderer</a></li><li><a href="module-ReportErrorCtrl.html">ReportErrorCtrl</a></li><li><a href="module-SaveScriptCtrl.html">SaveScriptCtrl</a></li><li><a href="module-uploader.html">uploader</a></li><li><a href="module-userConsole.html">userConsole</a></li><li><a href="module-userNotification.html">userNotification</a></li><li><a href="module-WaveforrmCache.html">WaveforrmCache</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addESTagToLog">addESTagToLog</a></li><li><a href="global.html#addESTagToNotLog">addESTagToNotLog</a></li><li><a href="global.html#addESTagToNotPrint">addESTagToNotPrint</a></li><li><a href="global.html#addESTagToPrint">addESTagToPrint</a></li><li><a href="global.html#esconsole">esconsole</a></li><li><a href="global.html#ESLog">ESLog</a></li><li><a href="global.html#formatResultForTests">formatResultForTests</a></li><li><a href="global.html#formatScriptForTests">formatScriptForTests</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#ServiceWrapper">ServiceWrapper</a></li><li><a href="global.html#setESConsoleTraceLevel">setESConsoleTraceLevel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Feb 11 2016 16:06:08 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
