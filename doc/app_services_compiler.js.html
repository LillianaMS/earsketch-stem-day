<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app/services/compiler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app/services/compiler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * An angular factory service for providing a compiler for scripts.
 *
 * @module compiler
 * @author Creston Bunch
 */
app.factory('compiler',
['pitchshifter', 'audioLibrary','audioContext','userConsole','$rootScope',
function compilerFactory(pitchshift, audioLibrary, audioContext, userConsole, $rootScope) {

    /**
     * After compiling code, go through each clip, load the audio file and
     * replace looped ones with multiple clips. Why? Because we don't know
     * the length of each audio clip until after compiling (unless we
     * loaded the clips before compiling and did this during compilation, but
     * that's harder.) Follow up with pitchshifting and setting the result
     * length.
     *
     * @param {object} result The compilation result object.
     * @returns {Promise} A promise that will resolve to the new result object.
     *
     * @private
     */
    function postCompile(result) {
        esconsole(
            'Compiling finishing. Loading audio buffers...',
            ['DEBUG','COMPILER']
        );

        // STEP 1: Load audio buffers needed for the result
        esconsole('Loading buffers.', ['DEBUG', 'COMPILER']);
        return loadBuffers(result).then(function(buffers) {
            esconsole('Filling in looped sounds.', ['DEBUG', 'COMPILER']);
            return buffers;
        }).catch(function(err) {
            throw err;

        // STEP 2: Insert buffers into clips and fix clip loops/effect lengths.
        }).then(function(buffers) {
            return fixClips(result, buffers);
        }).catch(function(err) {
            throw err;

        // STEP 3: Warn user about overlapping tracks
        }).then(function(result) {
            checkOverlaps(result);

            return result;
        }).catch(function(err) {
            throw err;

        // STEP 4: Pitchshift tracks that need it.
        }).then(function(result) {
            esconsole('Handling pitchshifted tracks.', ['DEBUG', 'COMPILER']);
            return handlePitchshift(result);
        }).catch(function(err) {
            throw err;

        // STEP 5: Insert metronome track in the end
        }).then(function(result) {
            esconsole('Adding metronome track.', ['DEBUG', 'COMPILER']);
            return addMetronome(result);
        }).catch(function(err) {
            throw err;

        // STEP 6: Return the post-compiled result
        }).then(function(result) {
            // print out string for unit tests
            esconsole(formatResultForTests(result), ['NOLOG', 'COMPILER']);
            return result;
        });
    }

    /**
     * Do not call this manually. This is for synchronizing the userConsole print out with the asyncPitchShift processing.
     * @param promises
     * @param result
     * @param i
     * @returns {array}
     */
    function recursivePSProcess(promises, result, i) {
        if (i &lt; result.tracks.length) {
            var track = result.tracks[i];

            if (track.effects['PITCHSHIFT-PITCHSHIFT_SHIFT'] !== undefined) {
                var p = pitchshift.asyncPitchshiftTrack(track, result.tempo);
                promises.push(p);
                p.then(function (track) {
                    userConsole.status('PITCHSHIFT applied on track ' + track['clips'][0]['track']);
                    $rootScope.$apply();
                    recursivePSProcess(promises, result, ++i);
                });
            } else {
                recursivePSProcess(promises, result, ++i);
            }
        }
        return promises;
    }

    /**
     * Pitchshift tracks in a result object because we can't yet make pitchshift
     * an effect node.
     *
     * @param {object} result The compiled result object.
     */
    function handlePitchshift(result) {

        esconsole('Begin pitchshifting.', ['DEBUG', 'COMPILER']);

        // This was the normal process call without userConsole synchronization
        //var promises = [];
        //for (var i = 1; i &lt; result.tracks.length; i++) {
        //    var track = result.tracks[i];
        //
        //    if (track.effects['PITCHSHIFT-PITCHSHIFT_SHIFT'] !== undefined){
        //        var p = pitchshift.asyncPitchshiftTrack(
        //            track, result.tempo
        //        );
        //        promises.push(p);
        //    }
        //}

        if (result.tracks.some(function (t) {
            return t.effects['PITCHSHIFT-PITCHSHIFT_SHIFT'] !== undefined;
        })) {
            userConsole.status('Applying PITCHSHIFT on track(s)');
            $rootScope.$apply();
        }

        // This is for synchronizing with userConsole print out
        var promises = recursivePSProcess([], result, 1);

        return Promise.all(promises).then(function() {
            esconsole('Pitchshifting promise resolved.',
                      ['DEBUG', 'COMPILER']);
            return result;
        }).catch(function(e) {
            esconsole(e, ['ERROR', 'COMPILER']);
            throw e;
        });
    }

    /**
     * Compile a python script.
     *
     * @param {string} code The code to run.
     * @param {int} quality Numeric value for the audio quality to load.
     * @returns {Promise} A promise that resolves to the compiled result object.
     */
    function compilePython(code, quality) {

        esconsole('Loading EarSketch library from: '+ SITE_BASE_URI
                  + '/scripts/src/api/earsketch.py.js');
        Sk.externalLibraries = {
            // import EarSketch library into skulpt
            earsketch : {
                path: SITE_BASE_URI + '/scripts/src/api/earsketch.py.js'
            }
        }

        var lines = code.match(/\n/g).length + 1;
        esconsole(
            'Compiling ' + lines + ' lines of Python', ['DEBUG','COMPILER']
        );

        // printing for unit tests
        esconsole(formatScriptForTests(code), ['NOLOG', 'COMPILER']);

        // STEP 1: get a list of constants from the server and inject them into
        // the skulpt list of builtins
        return audioLibrary.getAllTags().then(function(tags) {
            esconsole('Finished fetching audio tags', ['DEBUG','COMPILER']);
            // after loading audio tags, compile the script

            // inject audio constants into the skulpt builtin globals
            // TODO: come up with a proper solution for doing this in Skulpt
            // https://groups.google.com/forum/#!topic/skulpt/6C_TnxnP8P0
            for (var i in tags) {
                var tag = tags[i];
                if (!(tag in Sk.builtins)) {
                    Sk.builtins[tag] = Sk.ffi.remapToPy(tag);
                }
            }
            // inject audio quality as a builtin global, again not the ideal
            // solution but it works
            Sk.builtins['__AUDIO_QUALITY'] = quality;
        }).catch(function(err) {
            esconsole(err, ['ERROR','COMPILER']);
            throw new Error('Failed to load audio tags from the server.');
        // STEP 2: compile python code using Skulpt
        }).then(function() {
            esconsole('Compiling script using Skulpt.', ['DEBUG','COMPILER']);
            return Sk.misceval.asyncToPromise(function() {
                try {
                    return Sk.importMainWithBody("&lt;stdin>", false, code, true);
                } catch(err) {
                    esconsole(err, ['ERROR','COMPILER']);
                    throw err;
                };
            });
        }).catch(function(err) {
            throw err; // catch Skulpt errors

        // STEP 3: Extract the result object from within the EarSketch module.
        }).then(function(mod) {
            esconsole('Compiling finished. Extracting result.',
                      ['DEBUG','COMPILER']);
            // for P5 TODO: refactor P5
            __P5_MOD = mod;
            __P5_LANG = 'python';
            if (mod.$d.earsketch &amp;&amp; mod.$d.earsketch.$d._getResult) {
                // case: import earsketch
                var result = Sk.ffi.remapToJs(
                    Sk.misceval.call(mod.$d.earsketch.$d._getResult)
                );
                return result;
            } else if (mod.$d._getResult) {
                // case: from earsketch import *
                var result = Sk.ffi.remapToJs(
                    Sk.misceval.call(mod.$d._getResult)
                );
                return result;
            } else {
                throw new ReferenceError(
                    "Something went wrong. Skulpt did not provide the " +
                    "expected output.");
            }
        }).catch(function(err) {
            throw err;

        // STEP 4: Perform post-compilation steps on the result object
        }).then(function(result) {
            esconsole('Performing post-compilation steps.',
                      ['DEBUG','COMPILER']);
            return postCompile(result);
        }).catch(function(err) {
            throw err;
            //esconsole(err, ['ERROR','COMPILER']);
            //throw new Error(ESMessages.interpreter.internalerror);

        // STEP 5: finally return the result
        }).then(function(result) {
            esconsole('Post-compilation steps finished. Return result.',
                      ['DEBUG','COMPILER']);

            return result;
        });
    }

    /**
     * Compile a javascript script.
     *
     * @param {string} code The code to run.
     * @param {int} quality Numeric value for the audio quality to load.
     * @returns {Promise} A promise that resolves to the compiled result object.
     */
    function compileJavascript(code, quality) {

        // printing for unit tests
        esconsole(formatScriptForTests(code), ['NOLOG', 'COMPILER']);

        return audioLibrary.getAllTags().then(function(tags) {
            // after loading audio tags, compile the script
            esconsole('Finished fetching audio tags', ['DEBUG','COMPILER']);

            esconsole('Compiling script using JS-Interpreter.',
                      ['DEBUG','COMPILER']);

            try {
                var interpreter = new Interpreter(code, ES_JAVASCRIPT_API);
            } catch (e) {
                if (e.loc !== undefined) {
                    // acorn provides line numbers for syntax errors
                    e.message += ' on line ' + e.loc.line;
                    e.lineNumber = e.loc.line;
                }
                throw e;
            }

            // inject audio constants into the interpreter scope
            for (var i in tags) {
                var tag = tags[i];
                interpreter.setProperty(
                    interpreter.getScope(),
                    tag,
                    interpreter.createPrimitive(tag)
                );
            }
            // inject audio quality into the interpreter scope
            interpreter.setProperty(
                interpreter.getScope(),
                '__AUDIO_QUALITY',
                interpreter.createPrimitive(quality)
            )

            try {
                result = runJsInterpreter(interpreter);
                return result;
            } catch(e) {
                var lineNumber = getLineNumber(interpreter, code);
                if (typeof(e) === 'string') {
                    // js-interpreter sometimes returns strings
                    var err = new EvalError(
                        e + ' on line ' + lineNumber
                    );
                    err.lineNumber = lineNumber;
                    throw e;
                } else {
                    e.message += ' on line ' + lineNumber;
                    e.lineNumber = lineNumber;
                    throw e;
                }
            }
        }).catch(function(err) {
            throw err;
        }).then(function(result) {
            esconsole('Performing post-compilation steps.',
                      ['DEBUG','COMPILER']);
            return postCompile(result);
        }).catch(function(err) {
            throw err;
            //esconsole(err, ['ERROR','COMPILER']);
            //throw new Error(ESMessages.interpreter.internalerror);
        }).then(function(result) {
            esconsole('Post-compilation steps finished. Return result.',
                      ['DEBUG','COMPILER']);
            return result;
        });
    }

    /**
     * This is a helper function for running JS-Interpreter to handle
     * breaks in execution due to asynchronous calls. When an asynchronous
     * call is received, the interpreter will break execution and return true,
     * so we'll set a timeout to wait 200 ms and then try again until the
     * asynchronous calls are finished.
     *
     * @private
     */
    function runJsInterpreter(interpreter) {
        if (!interpreter.run()) {
            if (interpreter.__ES_FINISHED !== undefined) {

                esconsole('Compiling finished. Extracting result.',
                          ['DEBUG','COMPILER']);
                var result = interpreter.__ES_FINISHED;
                return result;
            } else {
                throw new ReferenceError(
                    'Missing call to finish() or something went wrong.'
                );
            }
        } else {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    try {
                        resolve(runJsInterpreter(interpreter, resolve, reject));
                    } catch(e) {
                        reject(e);
                    }
                }, 200);
            });
        }
    }

    /**
     * Compile a javascript script using native JS instead of JS-interpreter.
     * Right now only used because P5 does not play well with interpreted JS
     * or Python
     *
     * @param {string} code The code to run.
     * @param {int} quality Numeric value for the audio quality to load.
     * @returns {Promise} A promise that resolves to the compiled result object.
     */
    function compileNativeJavascript(code, quality) {
        return audioLibrary.getAllTags().then(function(tags) {
            // after loading audio tags, compile the script
            esconsole('Finished fetching audio tags', ['DEBUG','COMPILER']);

            // for P5 TODO: refactor P5
            __P5_LANG = 'javascript';

            esconsole('Compiling script using native Javascript.',
                      ['DEBUG','COMPILER']);
            try {
                // inject audio constants into the current scope
                for (var i in tags) {
                    var tag = tags[i];
                    window[tag] = tag;
                }

                // inject api functions into the current scope
                for (var key in ES_NATIVE_JAVASCRIPT_API) {
                    window[key] = ES_NATIVE_JAVASCRIPT_API[key];
                }
                // inject audio quality into the scope
                window['__AUDIO_QUALITY'] = quality;

                $.globalEval(code);

                esconsole('Compiling for P5 canvas.', ['DEBUG','COMPILER']);

                return __ES_RESULT;
            } catch (e) {
                throw e;
            }
        }).catch(function(err) {
            throw err;
        }).then(function(result) {
            esconsole('Performing post-compilation steps.',
                      ['DEBUG','COMPILER']);
            return postCompile(result);
        }).catch(function(err) {
            throw err;
            //esconsole(err, ['ERROR','COMPILER']);
            //throw new Error(ESMessages.interpreter.internalerror);
        }).then(function(result) {
            esconsole('Post-compilation steps finished. Return result.',
                      ['DEBUG','COMPILER']);

            return result;
        });

    }

    /**
     * Gets the current line number from the top of the JS-interpreter
     * stack trace.
     *
     * @private
     */
    var getLineNumber = function(interpreter, code) {
        // get the character start location from the stack
        var start = interpreter.stateStack[0].node.start;

        // count the number of new line characters
        return code.slice(0, start).match(/\n/g).length + 1;
    }


    function loadBuffers(result) {
        // first load all the buffers necessary
        var promises = [];
        for (var i in result.tracks) {
            var track = result.tracks[i];
            for (var j in track.clips) {
                var clip = track.clips[j];
                var promise = audioLibrary.getAudioClip(
                    clip.filekey, result.tempo, result.quality
                );
                promises.push(promise);
            }
        }

        return Promise.all(promises).then(function(buffers) {
            var map = {};
            for (var i = 0; i &lt; buffers.length; i++) {
                map[buffers[i].filekey] = buffers[i];
            }
            return map;
        }).catch(function(err) {
            throw err;
        });
    }

    /**
     * Fill in looped clips with multiple clips, and adjust effects with
     * end == 0.
     *
     * @private
     */
    function fixClips(result, buffers) {
        // step 1: fill in looped clips
        result.length = 0;
        for (var i in result.tracks) {
            var track = result.tracks[i];
            track.analyser = audioContext.createAnalyser();
            for (var j in track.clips) {
                var clip = track.clips[j];

                var buffer = buffers[clip.filekey];
                // add the buffer property
                clip.audio = buffer;

                // calculate the measure length of the clip
                var duration = ESUtilsTimeToMeasure(
                    buffer.duration, result.tempo
                );

                // if the clip end value is 0, set it to the duration
                // this fixes API calls insertMedia, etc. that don't
                // know the clip length ahead of time
                if (clip.end === 0) {
                    clip.end = 1+duration;
                }

                // calculate the remaining amount of time to fill
                var leftover = clip.end - clip.start - duration;

                // figure out how long the result is
                result.length = Math.max(
                    result.length,
                    clip.measure + (clip.end - clip.start) + clip.silence - 1
                );

                // update the source clip to reflect the new length
                clip.end = Math.min(1+duration, clip.end);
                clip.loopChild = false;

                // add clips to fill in empty space
                var i = 1;
                while (leftover > 0 &amp;&amp; clip.loop) {
                    var slice = Math.min(duration, leftover);
                    track.clips.push({
                        filekey: clip.filekey,
                        audio: clip.audio,
                        track: clip.track,
                        measure: clip.measure + (i * duration),
                        start: 1,
                        end: 1+slice,
                        scale: clip.scale,
                        loop: clip.loop,
                        loopChild: true
                    });
                    leftover -= slice;
                    i++;
                }
            }

            // fix effect lengths
            for (var key in track.effects) {
                if (track.effects.hasOwnProperty(key)) {
                    var effects = track.effects[key];
                    effects.sort(function (a, b) {
                        if (a.startMeasure &lt; b.startMeasure) {
                            return -1;
                        } else if (a.startMeasure > b.startMeasure) {
                            return 1;
                        } else {
                            return 0;
                        }
                    });
                    var endMeasureIfEmpty = result.length + 1;
                    for (var j = effects.length-1; j >= 0; j--) {
                        var effect = effects[j];
                        if (effect.endMeasure === 0) {
                            if (effect.startMeasure > endMeasureIfEmpty) {
                                effect.endMeasure = effect.startMeasure;
                            } else {
                                effect.endMeasure = endMeasureIfEmpty;
                            }
                            endMeasureIfEmpty = effect.startMeasure;
                        }
                    }

                    // if the automation start in the middle, it should fill the time before with the startValue of the earliest automation
                    if (effects[0].startMeasure > 1) {
                        var fillEmptyStart = Object.assign({}, effects[0]); // clone the earliest effect automation
                        fillEmptyStart.startMeasure = 1;
                        fillEmptyStart.endMeasure = effects[0].startMeasure;
                        fillEmptyStart.startValue = effects[0].startValue;
                        fillEmptyStart.endValue = effects[0].startValue;
                        fillEmptyStart.inputStartValue = effects[0].inputStartValue;
                        fillEmptyStart.inputEndValue = effects[0].inputStartValue;
                        effects.unshift(fillEmptyStart);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Warn users when a clips overlap each other. Done in post-compile because
     * we don't know the length of clips until then.
     *
     * @private
     */
    function checkOverlaps(result) {
        var truncateDigits = 10; // workaround for precision errors

        for (var i = 0; i &lt; result.tracks.length; i++) {
            var track = result.tracks[i];
            for (var j = 0; j &lt; track.clips.length; j++) {
                var clip = track.clips[j];
                for (var k = 0; k &lt; track.clips.length; k++) {
                    if (k == j) continue;
                    var sibling = track.clips[k];
                    var clipLeft = clip.measure;
                    var clipRight = clip.measure + truncate(clip.end - clip.start, truncateDigits);
                    var siblingLeft = sibling.measure;
                    var siblingRight = sibling.measure +
                        truncate(sibling.end - sibling.start, truncateDigits);
                    if ((clipLeft >= siblingLeft &amp;&amp; clipLeft &lt; siblingRight) ||
                        (clipRight > siblingLeft &amp;&amp; clipRight &lt;= siblingRight)) {
                        userConsole.warn(
                            'Overlapping clips ' + clip.filekey + ' and '
                            + sibling.filekey + ' on track ' + clip.track
                        );
                    }
                }

            }
        }
    }

    /**
     * Adds a metronome track to the end of a result.
     *
     * @private
     */
    function addMetronome(result) {
        return Promise.all([
            audioLibrary.getAudioClip('METRONOME01', undefined, result.quality),
            audioLibrary.getAudioClip('METRONOME02', undefined, result.quality)
        ]).then(
        function(r) {
            var track = {clips:[],effects:[]};
            for (var i = 1; i &lt; result.length+1; i+=0.25) {
                var filekey = 'METRONOME02';
                var audio = r[1];
                if (i%1 == 0) {
                    filekey = 'METRONOME01';
                    audio = r[0];
                }
                track.clips.push({
                    filekey: filekey,
                    audio: audio,
                    track: result.tracks.length,
                    measure: i,
                    start: 1,
                    end: 1.625,
                    scale: false,
                    loop: false,
                    loopChild: false
                });
            }
            // the metronome needs an analyzer too to prevent errors in player
            track.analyser = audioContext.createAnalyser();
            result.tracks.push(track);
            return result;
        }).catch(function(err) {
            throw err;
        });
    }


    /**
     * Return the public functions in this service.
     *
     * @returns {object} The public functions in this service.
     */
    return {
        postCompile: postCompile,
        compilePython: compilePython,
        compileJavascript: compileJavascript,
        compileNativeJavascript: compileNativeJavascript
    }

}]);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-accountController.html">accountController</a></li><li><a href="module-Analyze.html">Analyze</a></li><li><a href="module-apibrowserController.html">apibrowserController</a></li><li><a href="module-audioContext.html">audioContext</a></li><li><a href="module-audioeffects.html">audioeffects</a></li><li><a href="module-audioLibrary.html">audioLibrary</a></li><li><a href="module-autograderController.html">autograderController</a></li><li><a href="module-buildAudioNodeGraph.html">buildAudioNodeGraph</a></li><li><a href="module-changepasswordController.html">changepasswordController</a></li><li><a href="module-ColorPickerCtrl.html">ColorPickerCtrl</a></li><li><a href="module-compiler.html">compiler</a></li><li><a href="module-dawClip.html">dawClip</a></li><li><a href="module-dawClipName.html">dawClipName</a></li><li><a href="module-dawContainerController.html">dawContainerController</a></li><li><a href="module-dawController.html">dawController</a></li><li><a href="module-dawEffect.html">dawEffect</a></li><li><a href="module-dawTimeline.html">dawTimeline</a></li><li><a href="module-dawTrackController.html">dawTrackController</a></li><li><a href="module-DownloadFileCtrl.html">DownloadFileCtrl</a></li><li><a href="module-EarSketchApp.html">EarSketchApp</a></li><li><a href="module-forgotpasswordController.html">forgotpasswordController</a></li><li><a href="module-ideController.html">ideController</a></li><li><a href="module-JavascriptAPI.html">JavascriptAPI</a></li><li><a href="module-mainController.html">mainController</a></li><li><a href="module-NativeJavascriptAPI.html">NativeJavascriptAPI</a></li><li><a href="module-Passthrough.html">Passthrough</a></li><li><a href="module-pitchshifter.html">pitchshifter</a></li><li><a href="module-player.html">player</a></li><li><a href="module-PythonAPI.html">PythonAPI</a></li><li><a href="module-renameController.html">renameController</a></li><li><a href="module-renderer.html">renderer</a></li><li><a href="module-ReportErrorCtrl.html">ReportErrorCtrl</a></li><li><a href="module-SaveScriptCtrl.html">SaveScriptCtrl</a></li><li><a href="module-uploader.html">uploader</a></li><li><a href="module-userConsole.html">userConsole</a></li><li><a href="module-userNotification.html">userNotification</a></li><li><a href="module-WaveforrmCache.html">WaveforrmCache</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addESTagToLog">addESTagToLog</a></li><li><a href="global.html#addESTagToNotLog">addESTagToNotLog</a></li><li><a href="global.html#addESTagToNotPrint">addESTagToNotPrint</a></li><li><a href="global.html#addESTagToPrint">addESTagToPrint</a></li><li><a href="global.html#esconsole">esconsole</a></li><li><a href="global.html#ESLog">ESLog</a></li><li><a href="global.html#formatResultForTests">formatResultForTests</a></li><li><a href="global.html#formatScriptForTests">formatScriptForTests</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#ServiceWrapper">ServiceWrapper</a></li><li><a href="global.html#setESConsoleTraceLevel">setESConsoleTraceLevel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Feb 11 2016 16:06:08 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
