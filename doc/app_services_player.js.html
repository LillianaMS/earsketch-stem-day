<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app/services/player.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app/services/player.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * An angular factory that provides a service for playing sounds from the JSON
 * object output of scripts.
 *
 * @module player
 * @author Creston Bunch
 */
app.factory('player', ['audioContext', function compilerFactory(context) {

    /**
     * Build an audio context and play the result of a compiled script from
     * the given starting time.
     *
     * TODO: This function is too long, can we break it up?
     *
     * @param {object} result The output from the compiler. This must be the
     * result after compiler.finish() is called, so that each clip is loaded
     * with an audio buffer.
     * @param {float} origin The time (in seconds) to start playing at.
     * @param {array} mute A list of track indices to mute.
     * @param {array} bypass A list lists corresponding to each track
     * of effect hashes to bypass in the track.
     * @return {object} The result modified with clip play locations.
     */
    function playResult(result, origin, mute, bypass) {
        esconsole('Calling play starting at time ' + origin,
                  ['DEBUG','PLAYER']);

        // master node at which all effects converge
        result.master = context.createGain();
        result.master.connect(context.master);

        // we must go through every track and every audio clip and add each of
        // them to the audio context and start them at the right time
        for (var i = 0; i &lt; result.tracks.length; i++) {
            var track = result.tracks[i];
            if (mute.indexOf(i) > -1) {
                continue; // skip muted tracks
            }

            // get the list of bypassed effects for this track
            var trackBypass = bypass[i];
            esconsole('Bypassing effects: ' + JSON.stringify(trackBypass),
                      ['DEBUG','PLAYER']);

            // TODO: refactor applyeffects.js
            resetAudioNodeFlags();
            var startNode = buildAudioNodeGraph(
                context, track, i, result.tempo,
                origin, result.master, trackBypass, 0
            );

            var trackGain = context.createGain();
            trackGain.gain.setValueAtTime(1.0, 0);

            if(i == 0) {
                if (typeof(startNode) !== "undefined") {
                    result.master.connect(trackGain);
                    trackGain.connect(startNode.input);
                } else {
                    result.master.connect(trackGain);
                    trackGain.connect(track.analyser);
                    track.analyser.connect(context.destination);
                }
            }

            for (var j = 0; j &lt; track.clips.length; j++) {
                var clip = track.clips[j];

                // create the audio source node to contain the audio buffer
                // and play it at the designated time
                var source = context.createBufferSource();

                // Special case for pitchshifted tracks. The pitchshifted
                // audio buffer is different than the clip audio buffer, and
                // has different start and end times
                var pitchshiftEffect =
                    track.effects['PITCHSHIFT-PITCHSHIFT_SHIFT'];
                if (pitchshiftEffect !== undefined
                    &amp;&amp; !pitchshiftEffect.bypass) {
                    esconsole('Using pitchshifted audio for ' + clip.filekey +
                              ' on track ' + i,
                             ['DEBUG','PLAYER']);
                    source.buffer = clip.pitchshift.audio;
                    var start = ESUtilsMeasureToTime(
                        clip.pitchshift.start, result.tempo
                    );
                    var end = ESUtilsMeasureToTime(
                        clip.pitchshift.end, result.tempo
                    );
                // for all other tracks we can use the unprocessed clip buffer
                } else {
                    if (pitchshiftEffect !== undefined &amp;&amp;
                        pitchshiftEffect.bypass) {
                        esconsole(
                            'Bypassing pitchshift audio for ' + clip.filekey,
                            ['DEBUG', 'PLAYER']
                        );
                    }
                    source.buffer = clip.audio;
                    var start = ESUtilsMeasureToTime(clip.start, result.tempo);
                    var end = ESUtilsMeasureToTime(clip.end, result.tempo);
                }

                // connect the buffer source to the effects tree
                if (typeof(startNode) !== "undefined")  {
                    source.connect(trackGain);
                    trackGain.connect(startNode.input)
                } else {
                    //source.connect(result.master);
                    source.connect(trackGain);
                    trackGain.connect(track.analyser);
                    track.analyser.connect(context.destination);
                }

                var location = ESUtilsMeasureToTime(
                    clip.measure, result.tempo
                );

                // the clip duration may be shorter than the buffer duration
                var bufferDuration = source.buffer.duration;
                var clipDuration = end - start;

                if (origin > location &amp;&amp; origin > location + end) {
                    // case: clip is playing in the past
                    // do nothing, we don't have to play this clip

                } else if (origin > location
                           &amp;&amp; origin &lt; location + clipDuration) {
                    // case: clip is playing from the middle
                    // calculate the offset and begin playing
                    var offset = origin - location;
                    start += offset;
                    clipDuration -= offset;
                    source.start(context.currentTime, start, clipDuration);
                    source.stop(context.currentTime + clipDuration);

                    // keep this flag so we only stop clips that are playing
                    // (otherwise we get an exception raised)
                    clip.playing = true;
                } else {
                    // case: clip is in the future
                    // calculate when it should begin and register it to play
                    var offset = location - origin;

                    source.start(
                        context.currentTime + offset, start, clipDuration
                    );
                    clip.playing = true;
                }

                // keep a reference to this audio source so we can pause it
                clip.source = source;
                clip.gain = trackGain; // used to mute the track/clip
            }

        }

        return result;
    }

    /**
     * Pause a compiled script result currently being played.
     *
     * @param {object} result The compiled result object
     * reference obtained from player.play().
     */
    function pauseResult(result) {
        for (var i = 0; i &lt; result.tracks.length; i++) {
            var track = result.tracks[i];
            for (var j = 0; j &lt; track.clips.length; j++) {
                var clip = track.clips[j];

                if (clip.source !== undefined &amp;&amp; clip.playing) {
                    try {
                        clip.source.stop();
                    } catch(e) {
                        // TODO: Why does Safari throw an
                        // InvalidStateError
                        esconsole(e.toString(), ['WARNING','PLAYER']);
                    }
                    clip.source.disconnect();
                    clip.playing = false;
                }
            }
        }
        if (result.master !== undefined) {
            result.master.disconnect();
        }
    }

    /**
     * Mute a track currently playing in a given result object.
     *
     * @param {object} result The compiled result object
     * reference obtained from player.play().
     * @param {int} num The track number to mute.
     */
    function muteTrack(result, num) {
        var track = result.tracks[num];
        for (var i = 0; i &lt; track.clips.length; i++) {
            if (track.clips[i].gain !== undefined) {
                track.clips[i].gain.gain.setValueAtTime(0.0, 0);
            }
        }
    }

    /**
     * Unmute a track currently playing.
     *
     * @param {object} result The compiled result object
     * reference obtained from player.play().
     * @param {int} num The track number to unmute.
     */
    function unmuteTrack(result, num) {
        var track = result.tracks[num];
        for (var i = 0; i &lt; track.clips.length; i++) {
            if (track.clips[i].gain !== undefined) {
                track.clips[i].gain.gain.setValueAtTime(1.0, 0);
            }
        }
    }

    /**
     * Set the playback volume of a result.
     *
     * @param {result} context The compiled result object
     * reference obtained from player.play().
     * @param {float} gain The volume to play at in decibels.
     */

    function setVolume(result, gain) {
        esconsole('Setting context volume to ' + gain, ['DEBUG','PLAYER']);
        if (result.master !== undefined) {
            result.master.gain.value = dbToFloat(gain);
        }
    }

    return {
        playResult: playResult,
        pauseResult: pauseResult,
        muteTrack: muteTrack,
        unmuteTrack: unmuteTrack,
        setVolume: setVolume
    }

}]);

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-accountController.html">accountController</a></li><li><a href="module-Analyze.html">Analyze</a></li><li><a href="module-apibrowserController.html">apibrowserController</a></li><li><a href="module-audioContext.html">audioContext</a></li><li><a href="module-audioeffects.html">audioeffects</a></li><li><a href="module-audioLibrary.html">audioLibrary</a></li><li><a href="module-autograderController.html">autograderController</a></li><li><a href="module-buildAudioNodeGraph.html">buildAudioNodeGraph</a></li><li><a href="module-changepasswordController.html">changepasswordController</a></li><li><a href="module-ColorPickerCtrl.html">ColorPickerCtrl</a></li><li><a href="module-compiler.html">compiler</a></li><li><a href="module-dawClip.html">dawClip</a></li><li><a href="module-dawClipName.html">dawClipName</a></li><li><a href="module-dawContainerController.html">dawContainerController</a></li><li><a href="module-dawController.html">dawController</a></li><li><a href="module-dawEffect.html">dawEffect</a></li><li><a href="module-dawTimeline.html">dawTimeline</a></li><li><a href="module-dawTrackController.html">dawTrackController</a></li><li><a href="module-DownloadFileCtrl.html">DownloadFileCtrl</a></li><li><a href="module-EarSketchApp.html">EarSketchApp</a></li><li><a href="module-forgotpasswordController.html">forgotpasswordController</a></li><li><a href="module-ideController.html">ideController</a></li><li><a href="module-JavascriptAPI.html">JavascriptAPI</a></li><li><a href="module-mainController.html">mainController</a></li><li><a href="module-NativeJavascriptAPI.html">NativeJavascriptAPI</a></li><li><a href="module-Passthrough.html">Passthrough</a></li><li><a href="module-pitchshifter.html">pitchshifter</a></li><li><a href="module-player.html">player</a></li><li><a href="module-PythonAPI.html">PythonAPI</a></li><li><a href="module-renameController.html">renameController</a></li><li><a href="module-renderer.html">renderer</a></li><li><a href="module-ReportErrorCtrl.html">ReportErrorCtrl</a></li><li><a href="module-SaveScriptCtrl.html">SaveScriptCtrl</a></li><li><a href="module-uploader.html">uploader</a></li><li><a href="module-userConsole.html">userConsole</a></li><li><a href="module-userNotification.html">userNotification</a></li><li><a href="module-WaveforrmCache.html">WaveforrmCache</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addESTagToLog">addESTagToLog</a></li><li><a href="global.html#addESTagToNotLog">addESTagToNotLog</a></li><li><a href="global.html#addESTagToNotPrint">addESTagToNotPrint</a></li><li><a href="global.html#addESTagToPrint">addESTagToPrint</a></li><li><a href="global.html#esconsole">esconsole</a></li><li><a href="global.html#ESLog">ESLog</a></li><li><a href="global.html#formatResultForTests">formatResultForTests</a></li><li><a href="global.html#formatScriptForTests">formatScriptForTests</a></li><li><a href="global.html#getURLParameters">getURLParameters</a></li><li><a href="global.html#ServiceWrapper">ServiceWrapper</a></li><li><a href="global.html#setESConsoleTraceLevel">setESConsoleTraceLevel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Feb 11 2016 16:06:08 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
